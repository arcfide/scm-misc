\title{Predefined Foreign Types)%
The following are some types that should always be predefined. This
implementation is for Chez Scheme.

The [[foreign-integer]] type should represent the standard integer on 64-bit and
32-bit machines. This means that its size should be a signed 32-bit
integer on 32-bit machines, and a signed 64-bit integer on 64-bit
machines. 

While I could use the (machine-type) to get the integer size, I've 
decided that it is more flexible and nicer to use the
[[define-foreign-constants]] syntax. 

<<Types>>=
(define-foreign-constants ()
  ((size-of/integer int "int" "sizeof(int)")))

(define (unsupported-integer-size proc)
  (error proc "unsupported integer size"))

(define type 
  (case size-of/integer
    [(4) 'integer-32]
    [(8) 'integer-64]
    [else (unsupported-integer-size #f)]))
@

Every setter should handle the incoming structure as either a byte
vector or a pointer to a region in foreign allocated memory. I assume
that the [[val]] parameter here will be checked by the functions
[[bv-set!]] and [[#%$poke!]]. 

<<Types>>=
(define (foreign-integer-set! x offset val)
  (define bv-set!
    (case type 
      [(integer-32) bytevector-s32-native-set!]
      [(integer-64) bytevector-s64-native-set!]
      [else (unsupported-integer-size 'foreign-integer-set!)]))
  (cond
    [(bytevector? x) (bv-set! x offset val)]
    [(and (integer? x) (positive? x)) (#%$poke! type x offset val)]
    [else (errorf 'foreign-integer-set! "invalid foreign object ~s" x)]))
@

\noindent [[get-foreign-integer]] is the same as the above, except that
it does not take a value, obviously. 

<<Types>>=
(define (get-foreign-integer x offset)
  (define bv-ref
    (case type
      [(integer-32) bytevector-s32-native-ref]
      [(integer-64) bytevector-s64-native-ref]
      [else (unsupported-integer-size 'get-foreign-integer)]))
  (cond
    [(bytevector? x) (bv-ref x offset)]
    [(and (integer? x) (positive? x)) (#%$peek type x offset)]
    [else (errorf 'get-foreign-integer "invalid foreign object ~s" x)]))
@

\noindent All that is left is to define the constructor and the 
actual type.

<<Types>>=
(define (make-foreign-integer x)
  (let ([res (make-bytevector size-of/integer)])
    (foreign-integer-set! res 0 x)
    res))

(define-foreign-type foreign-integer size-of/integer
  make-foreign-integer get-foreign-integer foreign-integer-set!)
@

The [[foreign-char]] is a signed character type. At the moment I assume
that a character is a C 8-bit type, and I don't think this is going to
cause problems. {\it Note: famous last words.}

<<Types>>=
(define (get-foreign-char x offset)
  (integer->char
    (cond
      [(bytevecotr? x) (bytevector-s8-ref x offset)]
      [(and (integer? x) (positive? x)) (#%$peek 'signed-8 x offset)]
      [else 
        (errorf 'get-foreign-char "invalid foreign object ~s" x)])))
@

\noindent The setter is just about the same. I just make sure that the
character is actually in the right signed 8-bit range.

<<Types>>=
(define (foreign-char-set! x offset c)
  (let ([val (char->integer c)])
    (assert (<= -128 val 127))
    (cond
      [(bytevector? x) (bytevector-s8-set! x offset val)]
      [(and (integer? x) (positive? x)) (#%$poke! 'integer-8 x offset val)]
      [else 
        (errorf 'foreign-char-set! "invalid foreign object ~s" x)])))
@

\noindent Since R6RS characters are Unicode, we must make sure to check 
that the character we are assigning is a valid character. 

<<Types>>=
(define (make-foreign-char x)
  (let ([cval (char->integer x)])
    (assert (<= -128 cval 127))
    (let ([res (make-bytevector 1)])
      (foreign-char-set! res 0 cval)
      res)))

(define-foreign-type foreign-char 1
  make-foreign-char get-foreign-char foreign-char-set!)
@

\noindent For the moment, the idea of a string type as a fundamental 
type seems to work pretty well, so I am going to go for that.

<<Types>>=
(define foreign-string-transcoder 
  (make-transcoder (utf-8-codec) (eol-style none)))

(define (make-foreign-string x)
  (string->bytevector x foreign-string-transcoder))
@

\noindent When getting the string from a foreign structure, we provide
two different situations. One, we know the size, and we can safely do
whole block copies. In the other, we don't know the size, so we stick to
checking for the null character before we build the string.

<<Types>>=
(define get-foreign-string 
  (case-lambda
    [(x offset) 
     (get-foreign-string-of-length x offset
       (get-foreign-string-length x offset))]
    [(x offset len) (get-foreign-string-of-length x offset len)]))
@

\noindent If we do not know the length, we must scan the incoming string
for the null byte, which gives us a size, and we can then do the byte
copy, but not until then.

<<Types>>=
(define $strlen
  (foreign-procedure "strlen" (ptr) int))

(define (get-foreign-string-length x offset)
  (cond
    [(bytevector? x) 
     (let ([len (bytevector-length x)])
       (do ([i offset (1+ i)]) 
         [(or (>= i len) 
              (zero? (bytevector-u8-ref x i)))
          i]))]
    [(and (integer? x) (positive? x))
     ($strlen (+ x offset))]))
@

\noindent Once we know the length of the string or are given it
explicitly, we can use block copy operations to grab it. Note that in
the case where we don't know what we are doing, it might be easier to
just assign things explicitly as we count up the length. I don't know at
the moment, and this is easier, so I am going with it.

<<Types>>=
(define (get-foreign-string-of-length x offset len)
  (define $memcpy
    (foreign-procedure "memcpy" (string ptr int) ptr))
  (cond
    [(bytevecotr? x)
     (if (and (zero? offset) (= len (bytevector-length x)))
         (bytevector->string x foreign-string-transcoder)
         (let ([res (make-bytevector len)])
           (bytevector-copy! x offset res 0 len)
           (bytevector->string res foreign-string-transcoder)))]
    [(and (integer? x) (positive? x))
     (let ([res (make-bytevector len)])
       ($memcpy res x len)
       (bytevector->string res foreign-string-transcoder))]
    [else (errorf "Invalid foreign object ~s" x)]))
@

\noindent As with getting a foreign string, we allow the copying of a
string into a foreign string buffer. However, we must be especially
careful in the case when no string size is provided.

<<Types>>=
(define foreign-string-set! 
  (case-lambda
    [(x offset val)
     (foreign-string-set-size-unknown! x offset val)]
    [(x offset val len)
     (foreign-string-set-with-length! x offset val len)]))
@

\noindent When we don't have a length for the buffer explicitly, then we
have one of two possibilities. Either the buffer is a Scheme bytevector,
in which case we can check the sizes and everything is good. On the
other hand, if the buffer is referenced by a pointer value, then we
can't do this, and instead, we have to just break down into the unsafe
[[strcpy()]] operation.

<<Types>>=
(define $strcpy
  (foreign-procedure "strlen" (ptr string) ptr))

(define (foreign-string-set-size-unknown! x offset val)
  (cond
    [(bytevector? x)
     (let ([val-buf (string->bytevector val foreign-string-transcoder)]
           [val-len (string-length val)]
           [max-len (- (bytevector-length x) offset)])
       (bytevector-fill! x offset val-buf 0 (min val-len max-len)))]
    [(and (integer? x) (positive? x))
     ($strcpy (+ x offset) val)
     (void)]))
@

\noindent If we do know the size of the destination buffer, life becomes
much easier. 

<<Types>>=
(define (foreign-string-set-with-length! x offset val len)
  (define $memcpy
    (foreign-procedure "memcpy" (ptr string int) ptr))
  (cond
    [(bytevector? x)
     (bytevector-fill! 
       x offset 
       (string->bytevector val foreign-string-transcoder) 0
       len)]
    [(and (integer? x) (positive? x))
     ($memcpy x val (min (string-length val) (- len offset 1)))
     (#%$poke! 'integer-8 x (1- len) 0)]))
@

\noindent We can't define a foreign type just yet, because we don't know
ahead of time the size of a string. However, the user can do that easily
enough and use these string functions to do it. 

\title{Predefined Foreign Types)%
The following are some types that should always be predefined. This
implementation is for Chez Scheme.

While foreign integers are useful, getting the right size value is
annoying, so the following is a general syntax for defining integer
types.

<<Types>>=
(define-auxilary-keywords signed unsigned)

(define-syntax define-foreign-integer-type
  (syntax-rules (signed unsigned)
    [(_ (name constructor getter setter!) size)
     (define-integer-type 
       (name constructor getter setter!) 
       signed
       size)]
    [(_ (name constructor getter setter!) unsigned size)
     (begin
       (define size-val size)
       (define type
         (case size-val
           [(1) 'unsigned-8]
           [(2) 'unsigned-16]
           [(4) 'unsigned-32]
           [(8) 'unsigned-64]
           [else (unsupported-integer-size #f size-val)]))
       (%define-type type size-val name constructor getter setter!)
       (define-foreign-type name size-val constructor getter setter!))]
    [(_ (name constructor getter setter!) signed size)
     (begin
       (define size-val size)
       (define type
         (case size-val
           [(1) 'integer-8]
           [(2) 'integer-16]
           [(4) 'integer-32]
           [(8) 'integer-64]
           [else (unsupported-integer-size #f size-val)]))
       (%define-type type size-val name constructor getter setter!)
       (define-foreign-type name size-val constructor getter setter!))]))
@

\noindent [[%define-type]] first defines an appropriate bytevector
setter and getter, and then defines the standard versions of integer
accessors and mutators.

<<Types>>=
(define-syntax %define-type
  (syntax-rules ()
    [(_ type size name const get set!)
     (begin
       (define bv-ref
         (case type
           [(integer-8) bytevector-s8-ref]
           [(unsigned-8) bytevector-u8-ref]
           [(integer-16) bytevector-s16-native-ref]
           [(unsigned-16) bytevector-u16-native-ref]
           [(integer-32) bytevector-s32-native-ref]
           [(unsigned-32) bytevector-u32-native-ref]
           [(integer-64) bytevector-s64-native-ref]
           [(unsigned-64) bytevector-u64-native-ref]
           [else (unsupported-integer-size 'get type)]))
       (define bv-set!
        (case type
          [(integer-8) bytevector-s8-set!]
          [(unsigned-8) bytevector-u8-set!]
          [(integer-16) bytevector-s16-native-set!]
          [(unsigned-16) bytevector-u16-native-set!]
          [(integer-32) bytevector-s32-native-set!]
          [(unsigned-32) bytevector-u32-native-set!]
          [(integer-64) bytevector-s64-native-set!]
          [(unsigned-64) bytevector-u64-native-set!]
          [else (unsupported-integer-size 'set! type)]))
       (define (set! x offset val)
         (cond
           [(bytevector? x) (bv-set! x offset val)]
           [(and (integer? x) (positive? x)) (#%$poke! x type offset val)]
           [else (invalid-object 'set! x)]))
       (define (get x offset)
         (cond
           [(bytevector? x) (bv-ref x offset)]
           [(and (integer? x) (positive? x)) (#%$peek x type offset)]
           [else (invalid-object 'get x)]))
       (define (const x)
         (let ([res (make-bytevector size)])
           (set! res 0 x)
           res)))]))
@

\noindent Above we use the same error messages so we put them into handy
procedures.

<<Types>>=
(define (unsupported-integer-size proc-name size)
  (errorf proc-name "Unsupported integer size ~s" size))
(define (invalid-object proc-name val)
  (errorf proc-name "Invalid foreign object ~s" val))
@

\noindent For example, we could use this to define [[foreign-char]].

<<Types>>=
(define-foreign-integer-type
  (foreign-char make-foreign-char get-foreign-char foreign-char-set!)
  signed
  1)
@

\noindent For the moment, the idea of a string type as a fundamental 
type seems to work pretty well, so I am going to go for that.

<<Types>>=
(define foreign-string-transcoder 
  (make-transcoder (utf-8-codec) (eol-style none)))

(define (make-foreign-string x)
  (string->bytevector x foreign-string-transcoder))
@

\noindent When getting the string from a foreign structure, we provide
two different situations. One, we know the size, and we can safely do
whole block copies. In the other, we don't know the size, so we stick to
checking for the null character before we build the string.

<<Types>>=
(define get-foreign-string 
  (case-lambda
    [(x offset) 
     (get-foreign-string-of-length x offset
       (get-foreign-string-length x offset))]
    [(x offset len) (get-foreign-string-of-length x offset len)]))
@

\noindent If we do not know the length, we must scan the incoming string
for the null byte, which gives us a size, and we can then do the byte
copy, but not until then.

<<Types>>=
(define $strlen
  (foreign-procedure "strlen" (ptr) int))

(define (get-foreign-string-length x offset)
  (cond
    [(bytevector? x) 
     (let ([len (bytevector-length x)])
       (do ([i offset (1+ i)]) 
         [(or (>= i len) 
              (zero? (bytevector-u8-ref x i)))
          (- i offset)]))]
    [(and (integer? x) (positive? x))
     ($strlen (+ x offset))]))
@

\noindent Once we know the length of the string or are given it
explicitly, we can use block copy operations to grab it. Note that in
the case where we don't know what we are doing, it might be easier to
just assign things explicitly as we count up the length. I don't know at
the moment, and this is easier, so I am going with it.

<<Types>>=
(define (get-foreign-string-of-length x offset len)
  (define $memcpy
    (foreign-procedure "memcpy" (string ptr int) ptr))
  (cond
    [(bytevector? x)
     (if (and (zero? offset) (= len (bytevector-length x)))
         (bytevector->string x foreign-string-transcoder)
         (let ([res (make-bytevector len)])
           (bytevector-copy! res 0 x offset (- len offset))
           (bytevector->string res foreign-string-transcoder)))]
    [(and (integer? x) (positive? x))
     (let ([res (make-bytevector len)])
       ($memcpy res x len)
       (bytevector->string res foreign-string-transcoder))]
    [else (errorf "Invalid foreign object ~s" x)]))
@

\noindent As with getting a foreign string, we allow the copying of a
string into a foreign string buffer. However, we must be especially
careful in the case when no string size is provided.

<<Types>>=
(define foreign-string-set! 
  (case-lambda
    [(x offset val)
     (foreign-string-set-size-unknown! x offset val)]
    [(x offset val len)
     (foreign-string-set-with-length! x offset val len)]))
@

\noindent When we don't have a length for the buffer explicitly, then we
have one of two possibilities. Either the buffer is a Scheme bytevector,
in which case we can check the sizes and everything is good. On the
other hand, if the buffer is referenced by a pointer value, then we
can't do this, and instead, we have to just break down into the unsafe
[[strcpy()]] operation.

<<Types>>=
(define $strcpy
  (foreign-procedure "strlen" (ptr string) ptr))

(define (foreign-string-set-size-unknown! x offset val)
  (cond
    [(bytevector? x)
     (let ([val-buf (string->bytevector val foreign-string-transcoder)]
           [val-len (string-length val)]
           [max-len (- (bytevector-length x) offset)])
       (bytevector-copy! val-buf 0 x offset (min val-len max-len)))]
    [(and (integer? x) (positive? x))
     ($strcpy (+ x offset) val)
     (void)]))
@

\noindent If we do know the size of the destination buffer, life becomes
much easier. 

<<Types>>=
(define (foreign-string-set-with-length! x offset val len)
  (define $memcpy
    (foreign-procedure "memcpy" (ptr string int) ptr))
  (cond
    [(bytevector? x)
     (bytevector-copy! 
       (string->bytevector val foreign-string-transcoder) 0
       x offset 
       (- len offset))]
    [(and (integer? x) (positive? x))
     ($memcpy x val (min (string-length val) (- len offset 1)))
     (#%$poke! 'integer-8 x (1- len) 0)]))
@

\noindent We can't define a foreign type just yet, because we don't know
ahead of time the size of a string. However, the user can do that easily
enough and use these string functions to do it. 

\chapter{Imports and Exports}%

<<Exports>>=
define-foreign-integer-type
get-foreign-char foreign-char-set! make-foreign-char foreign-char
make-foreign-string get-foreign-string foreign-string-set!
unsigned signed
@

<<Imports>>=
(chezscheme)
(arcfide ffi-bind)
(arcfide extended-definitions)
@

\chapter{Files}%
The following chunks are for file export or tangling.

<<types.chezscheme.scm>>=
<<License>>

<<Types>>
@

<<types.chezscheme.sls>>=
<<License>>

#!chezscheme
(library (arcfide ffi-bind types)
  (export 
    <<Exports>>)
  (import 
    <<Imports>>)
  
<<Types>>

)
@

<<types.chezscheme.ss>>=
<<License>>

#!chezscheme
(module arcfide/ffi-bind/types
  (<<Exports>>)
  (import 
    <<Imports>>)

<<Types>>

)
@

\chapter{Licensing}%

<<License>>=
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Default Type Definitions and Utilities for FFI Foreign Types
;;; Version: 1.0
;;; 
;;; Copyright (c) 2009 Aaron W. Hsu <arcfide@sacrideo.us>
;;; 
;;; Permission to use, copy, modify, and distribute this software for
;;; any purpose with or without fee is hereby granted, provided that the
;;; above copyright notice and this permission notice appear in all
;;; copies.
;;; 
;;; THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
;;; WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED
;;; WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
;;; AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
;;; DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA
;;; OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
;;; TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
;;; PERFORMANCE OF THIS SOFTWARE.
@

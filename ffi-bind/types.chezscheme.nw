\title{Predefined Foreign Types)%
The following are some types that should always be predefined. This
implementation is for Chez Scheme.

The [[foreign-integer]] type should represent the standard integer on 64-bit and
32-bit machines. This means that its size should be a signed 32-bit
integer on 32-bit machines, and a signed 64-bit integer on 64-bit
machines. 

While I could use the (machine-type) to get the integer size, I've 
decided that it is more flexible and nicer to use the
[[define-foreign-constants]] syntax. 

<<Types>>=
(define-foreign-constants ()
  ((size-of/integer int "int" "sizeof(int)")))

(define (unsupported-integer-size proc)
  (error proc "unsupported integer size"))

(define type 
  (case size-of/integer
    [(4) 'integer-32]
    [(8) 'integer-64]
    [else (unsupported-integer-size #f)]))
@

Every setter should handle the incoming structure as either a byte
vector or a pointer to a region in foreign allocated memory. I assume
that the [[val]] parameter here will be checked by the functions
[[bv-set!]] and [[#%$poke!]]. 

<<Types>>=
(define (foreign-integer-set! x offset val)
  (define bv-set!
    (case type 
      [(integer-32) bytevector-s32-native-set!]
      [(integer-64) bytevector-s64-native-set!]
      [else (unsupported-integer-size 'foreign-integer-set!)]))
  (cond
    [(bytevector? x) (bv-set! x offset val)]
    [(and (integer? x) (positive? x)) (#%$poke! type x offset val)]
    [else (errorf 'foreign-integer-set! "invalid foreign object ~s" x)]))
@

\noindent [[get-foreign-integer]] is the same as the above, except that
it does not take a value, obviously. 

<<Types>>=
(define (get-foreign-integer x offset)
  (define bv-ref
    (case type
      [(integer-32) bytevector-s32-native-ref]
      [(integer-64) bytevector-s64-native-ref]
      [else (unsupported-integer-size 'get-foreign-integer)]))
  (cond
    [(bytevector? x) (bv-ref x offset)]
    [(and (integer? x) (positive? x)) (#%$peek type x offset)]
    [else (errorf 'get-foreign-integer "invalid foreign object ~s" x)]))
@

\noindent All that is left is to define the constructor and the 
actual type.

<<Types>>=
(define (make-foreign-integer x)
  (let ([res (make-bytevector size-of/integer)])
    (foreign-integer-set! res 0 x)
    res))

(define-foreign-type foreign-integer size-of/integer
  make-foreign-integer get-foreign-integer foreign-integer-set!)
@

The [[foreign-char]] is a signed character type. At the moment I assume
that a character is a C 8-bit type, and I don't think this is going to
cause problems. {\it Note: famous last words.}

<<Types>>=
(define (get-foreign-char x offset)
  (integer->char
    (cond
      [(bytevecotr? x) (bytevector-s8-ref x offset)]
      [(and (integer? x) (positive? x)) (#%$peek 'signed-8 x offset)]
      [else 
        (errorf 'get-foreign-char "invalid foreign object ~s" x)])))
@

\noindent The setter is just about the same. I just make sure that the
character is actually in the right signed 8-bit range.

<<Types>>=
(define (foreign-char-set! x offset c)
  (let ([val (char->integer c)])
    (assert (<= -128 val 127))
    (cond
      [(bytevector? x) (bytevector-s8-set! x offset val)]
      [(and (integer? x) (positive? x)) (#%$poke! 'integer-8 x offset val)]
      [else 
        (errorf 'foreign-char-set! "invalid foreign object ~s" x)])))
@

\noindent Since R6RS characters are Unicode, we must make sure to check 
that the character we are assigning is a valid character. 

<<Types>>=
(define (make-foreign-char x)
  (let ([cval (char->integer x)])
    (assert (<= -128 cval 127))
    (let ([res (make-bytevector 1)])
      (foreign-char-set! res 0 cval)
      res)))

(define-foreign-type foreign-char 1
  make-foreign-char get-foreign-char foreign-char-set!)
@


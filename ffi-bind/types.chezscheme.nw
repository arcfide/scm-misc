\title{Predefined Foreign Types)%
The following are some types that should always be predefined. This
implementation is for Chez Scheme.

\chapter{Integers}%
While foreign integers are useful, getting the right size value is
annoying, so the following is a general syntax for defining integer
types.

<<Types>>=
(define-auxilary-keywords signed unsigned)

(define-syntax define-foreign-integer-type
  (syntax-rules (signed unsigned)
    [(_ (name constructor getter setter!) size)
     (define-foreign-integer-type 
       (name constructor getter setter!) 
       signed
       size
       (native-endianness))]
    [(_ (name constructor getter setter!) unsigned size endian)
     (begin
       (define size-val size)
       (define endian-val endian)
       (define type (get-type 'unsigned size-val))
       (%define-type 
         type size-val endian-val 
         name constructor getter setter!)
       (define-foreign-type name size-val constructor getter setter!))]
    [(_ (name constructor getter setter!) signed size endian)
     (begin
       (define size-val size)
       (define endian-val endian)
       (define type (get-type 'signed size-val))
       (%define-type 
         type size-val endian-val 
         name constructor getter setter!)
       (define-foreign-type name size-val constructor getter setter!))]))
@

\noindent The integer type can be signed/unsigned and 1, 2, 4, or 8
bytes.

<<Types>>=
(define (get-type sign size)
  (if (eq? 'signed sign)
      (case size
        [(1) 'integer-8]
        [(2) 'integer-16]
        [(4) 'integer-32]
        [(8) 'integer-64]
        [else (unsupported-integer-size #f size)])
      (case size
        [(1) 'unsigned-8]
        [(2) 'unsigned-16]
        [(4) 'unsigned-32]
        [(8) 'unsigned-64]
        [else (unsupported-integer-size #f size)])))
@
      
\noindent [[%define-type]] first defines an appropriate bytevector
setter and getter, and then defines the standard versions of integer
accessors and mutators.

<<Types>>=
(define-syntax %define-type
  (syntax-rules ()
    [(_ type size endian name const get set!)
     (begin
       (define bv-ref (make-ref-type type endian))
       (define bv-set! (make-set-type type endian))
       (define bv-native-ref (make-native-ref-type type endian))
       (define switch (make-switcher bv-native-ref bv-set! size))
       (define (set! x offset val)
         (cond
           [(bytevector? x) (bv-set! x offset val)]
           [(and (integer? x) (positive? x)) 
            (#%$poke! x type offset (switch val))]
           [else (invalid-object 'set! x)]))
       (define (get x offset)
         (cond
           [(bytevector? x) (bv-ref x offset)]
           [(and (integer? x) (positive? x)) 
            (switch (#%$peek type x offset))]
           [else (invalid-object 'get x)]))
       (define (const x)
         (let ([res (make-bytevector size)])
           (set! res 0 x)
           res)))]))
@

\noindent Making the reference procedure consists of choosing the right
bytevector procedure for the given type:

<<Types>>=
(define (make-ref endian proc)
  (lambda (bv n) (proc bv n endian)))
  
(define (make-ref-type type endian)
  (case type
    [(integer-8) bytevector-s8-ref]
    [(unsigned-8) bytevector-u8-ref]
    [(integer-16) (make-ref endian bytevector-s16-ref)]
    [(unsigned-16) (make-ref endian bytevector-u16-ref)]
    [(integer-32) (make-ref endian bytevector-s32-ref)]
    [(unsigned-32) (make-ref endian bytevector-u32-ref)]
    [(integer-64) (make-ref endian bytevector-s64-ref)]
    [(unsigned-64) (make-ref endian bytevector-u64-ref)]
    [else (unsupported-integer-size 'get type)]))
@

\noindent We need to have a native getter in any case, since we have to
convert the endianness on foreign pointer types.

<<Types>>=
(define (make-native-ref-type type endian)
  (case type
    [(integer-8) bytevector-s8-ref]
    [(unsigned-8) bytevector-u8-ref]
    [(integer-16) bytevector-s16-native-ref]
    [(unsigned-16) bytevector-u16-native-ref]
    [(integer-32) bytevector-s32-native-ref]
    [(unsigned-32) bytevector-u32-native-ref]
    [(integer-64) bytevector-s64-native-ref]
    [(unsigned-64) bytevector-u64-native-ref]
    [else (unsupported-integer-size 'get type)]))
@

\noindnet The Setter procedure maker is basically the same.

<<Types>>=
(define (make-set endian proc)
  (lambda (bv n v) (proc bv n v endian)))
  
(define (make-set-type type endian)
  (case type
    [(integer-8) bytevector-s8-set!]
    [(unsigned-8) bytevector-u8-set!]
    [(integer-16) (make-set endian bytevector-s16-set!)]
    [(unsigned-16) (make-set endian bytevector-u16-set!)]
    [(integer-32) (make-set endian bytevector-s32-set!)]
    [(unsigned-32) (make-set endian bytevector-u32-set!)]
    [(integer-64) (make-set endian bytevector-s64-set!)]
    [(unsigned-64) (make-set endian bytevector-u64-set!)]
    [else (unsupported-integer-size 'set! type)]))
@

\noindent We need to be able to convert from little to big endian and
vice versa for when we use the [[#%$peek]] and [[#%$poke]] features of
Chez Scheme.

<<Types>>=
(define (make-switcher ref set! size)
  (lambda (val)
    (let ([res (make-bytevector size)])
      (set! res 0 val)
      (ref res 0))))
@

\noindent Above we use the same error messages so we put them into handy
procedures.

<<Types>>=
(define (unsupported-integer-size proc-name size)
  (errorf proc-name "Unsupported integer size ~s" size))
(define (invalid-object proc-name val)
  (errorf proc-name "Invalid foreign object ~s" val))
@

\section{Character Type}%
For example, we could use this to define [[foreign-char]].

<<Types>>=
(define-foreign-integer-type
  (foreign-char make-foreign-char get-foreign-char foreign-char-set!)
  1)
@

\chapter{String Utilities}%
For the moment, the idea of a string type as a fundamental 
type seems to work pretty well, so I am going to go for that.

<<Types>>=
(define foreign-string-transcoder 
  (make-transcoder (latin-1-codec) (eol-style none)))

(define (make-foreign-string x)
  (string->bytevector x foreign-string-transcoder))
@

\noindent When getting the string from a foreign structure, we provide
two different situations. One, we know the size, and we can safely do
whole block copies. In the other, we don't know the size, so we stick to
checking for the null character before we build the string.

<<Types>>=
(define get-foreign-string 
  (case-lambda
    [(x offset) 
     (get-foreign-string-of-length x offset
       (get-foreign-string-length x offset))]
    [(x offset len) (get-foreign-string-of-length x offset len)]))
@

\noindent If we do not know the length, we must scan the incoming string
for the null byte, which gives us a size, and we can then do the byte
copy, but not until then.

<<Types>>=
(define $strlen
  (foreign-procedure "strlen" (uptr) int))

(define (get-foreign-string-length x offset)
  (cond
    [(bytevector? x) 
     (let ([len (bytevector-length x)])
       (do ([i offset (1+ i)]) 
         [(or (>= i len) 
              (zero? (bytevector-u8-ref x i)))
          (- i offset)]))]
    [(and (integer? x) (positive? x))
     ($strlen (+ x offset))]))
@

\noindent Once we know the length of the string or are given it
explicitly, we can use block copy operations to grab it. Note that in
the case where we don't know what we are doing, it might be easier to
just assign things explicitly as we count up the length. I don't know at
the moment, and this is easier, so I am going with it.

<<Types>>=
(define $memcpy-gfsol
  (foreign-procedure "memcpy" (string uptr unsigned) ptr))

(define (get-foreign-string-of-length x offset len)
  (cond
    [(zero? len) ""]
    [(bytevector? x)
     (if (and (zero? offset) (= len (bytevector-length x)))
         (bytevector->string x foreign-string-transcoder)
         (let ([res (make-bytevector len)])
           (bytevector-copy! res 0 x offset len)
           (bytevector->string res foreign-string-transcoder)))]
    [(and (integer? x) (positive? x))
     (let ([res (make-bytevector len)])
       ($memcpy-gfsol res (+ x offset) len)
       (bytevector->string res foreign-string-transcoder))]
    [else (errorf "Invalid foreign object ~s" x)]))
@

\noindent As with getting a foreign string, we allow the copying of a
string into a foreign string buffer. However, we must be especially
careful in the case when no string size is provided.

<<Types>>=
(define foreign-string-set! 
  (case-lambda
    [(x offset val)
     (foreign-string-set-size-unknown! x offset val)]
    [(x offset val len)
     (foreign-string-set-with-length! x offset val len)]))
@

\noindent When we don't have a length for the buffer explicitly, then we
have one of two possibilities. Either the buffer is a Scheme bytevector,
in which case we can check the sizes and everything is good. On the
other hand, if the buffer is referenced by a pointer value, then we
can't do this, and instead, we have to just break down into the unsafe
[[strcpy()]] operation.

<<Types>>=
(define $strcpy
  (foreign-procedure "strlen" (ptr string) ptr))

(define (foreign-string-set-size-unknown! x offset val)
  (let ([val-buf (string->bytevector val foreign-string-transcoder)]
        [val-len (string-length val)])
    (cond 
      [(bytevector? x)
       (assert (<= val-len (- (bytevector-length x) offset)))
       (bytevector-copy! val-buf 0 x offset val-len)]
      [(and (integer? x) (positive? x))
       ($strcpy (+ x offset) val)
       (void)]
      [else (errorf "Invalid foreign object ~s" x)])))
@

\noindent If we do know the size of the destination buffer, life becomes
much easier. 

<<Types>>=
(define $memcpy-fsswl
  (foreign-procedure "memcpy" (ptr string int) ptr))

(define (foreign-string-set-with-length! x offset val len)
  (cond
    [(bytevector? x)
     (bytevector-copy! 
       (string->bytevector val foreign-string-transcoder) 0
       x offset 
       (- len offset))]
    [(and (integer? x) (positive? x))
     (let ([ffi-len (min (string-length val) (- len offset 1))])
       ($memcpy-fsswl (+ x offset) val ffi-len)
       (#%$poke! 'integer-8 x (+ offset ffi-len 1)  0))]
    [else (errorf "Invalid foreign object ~s" x)]))
@

\noindent We can't define a foreign type just yet, because we don't know
ahead of time the size of a string. However, the user can do that easily
enough and use these string functions to do it. 

\chapter{Imports and Exports}%

<<Exports>>=
define-foreign-integer-type
get-foreign-char foreign-char-set! make-foreign-char foreign-char
make-foreign-string get-foreign-string foreign-string-set!
unsigned signed
@

<<Imports>>=
(chezscheme)
(arcfide ffi-bind)
(arcfide extended-definitions)
@

\chapter{Files}%
The following chunks are for file export or tangling.

<<types.chezscheme.scm>>=
<<License>>

<<Types>>
@

<<types.chezscheme.sls>>=
<<License>>

#!chezscheme
(library (arcfide ffi-bind types)
  (export 
    <<Exports>>)
  (import 
    <<Imports>>)
  
<<Types>>

)
@

<<types.chezscheme.ss>>=
<<License>>

#!chezscheme
(module arcfide/ffi-bind/types
  (<<Exports>>)
  (import 
    <<Imports>>)

<<Types>>

)
@

\chapter{Licensing}%

<<License>>=
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Default Type Definitions and Utilities for FFI Foreign Types
;;; Version: 1.0
;;; 
;;; Copyright (c) 2009 Aaron W. Hsu <arcfide@sacrideo.us>
;;; 
;;; Permission to use, copy, modify, and distribute this software for
;;; any purpose with or without fee is hereby granted, provided that the
;;; above copyright notice and this permission notice appear in all
;;; copies.
;;; 
;;; THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
;;; WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED
;;; WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
;;; AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
;;; DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA
;;; OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
;;; TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
;;; PERFORMANCE OF THIS SOFTWARE.
@

\title{Sockets in Chez Scheme}

\chapter{Introduction}

This is a socket library for Chez Scheme which attempts to remain 
as faithful as possible to BSD sockets while still maintaining a 
normal operation that will be familiar to Scheme programmers.
Procedures are documented inline at the top of their main
definitions. 

The current implementation uses records instead of magic numbers. 
Hopefully this keeps the system a little more portable.
Only Internet and Local/Unix domain sockets are supported 
by this code, though additional types should be relatively easy 
to make.

The code itself is organized into 
new socket datatypes and procedures. 
Each relevant chapter discusses these parts in particular detail.
The constants section describes how to extend the constants 
defined for socket procedures.

The library also includes a C Stub and FFI interface to enable the 
low-level data manipulations and system calls when necessary. 

A build script also accompanies the library to help in the building of 
the code on some platforms. It is only meant as a guide, and may not 
work completely on your system.

\chapter{Uncompleted/Planned Features}

The following is a development to-do list of intended features 
and possible improvements.

\orderedlist
\li Error checking and handling
\li Non-blocking Sockets
\li Sockets Options
\li Remove Magic Constants from lookup\_proto
\li Remove excess amount of conversion functions
\li Switch to or make UNIX another optional name for LOCAL
\li Consider IP field name replaced with ADDRESS
\li COnsider name change of RECEIVE-FROM-SOCKET
\li Consider name change of ACCEPT-SOCKET
\li Better handling of paths in UNIX sockets
\endorderedlist

\chapter{Socket Datatypes}

\section{Sockets}

<<Exports>>=
make-socket
socket?
socket-fd
socket-domain
socket-type
socket-protocol
@

Sockets are file descriptors which usually have integer representations. 
The [[socket]] datatype also defines fields for easily determining 
the domain, the type, and the protocol of the socket.

<<Datatypes>>=
(define-record-type socket (fields fd domain type protocol))
@

The [[fd]] field should be a socket field descriptor, which is a positive integer. 
The [[domain]], [[type]], and [[protocol]] fields all contain constants which 
return true for 
[[socket-domain?]], [[socket-type?]], and [[socket-protocol?]], respectively. 
This functionality could be introspected from the field descriptor, but it 
is more convenient to store this information directly.

\section{Socket Addresses}

<<Exports>>=
socket-address?
socket-address
@

Other than sockets, one must also have a means by which to address other hosts. 
Socket Addresses represent the destinations or origins of transmissions. 

All socket address data types are subtypes of [[socket-address]]es.

<<Datatypes>>=
(define-record-type socket-address (fields converter))
@

\subsection{Converting Socket Addresses}

\noindent When passing socket addresses to foreign procedures, 
we must first convert these Scheme datatypes to a proper foreign socket 
address structure.
To do this, every child of the [[socket-address]] type 
must provide a converter. 
This should be defined by default, and it should not be necessary 
for the user to specify the converter.
The converter should accept the socket address type 
for which it is defined as its sole argument. 
It should then return a bytevector that represents the 
foreign structure. 

Internally, when we need to communicate with a foreign 
procedure that expects a socket address, we use the following 
wrapper.

<<Datatypes>>=
(define (socket-address->foreign sock-addr)
  ((socket-address-converter sock-addr) sock-addr))

@

If we need to convert an unknown address type into a 
Scheme data structure, we use the following.

<<Datatypes>>=
(define (foreign->socket-address domain addr addr-len)
  ((socket-domain-extractor domain) addr addr-len))

@

When constructing a bytevector container for foreign code, 
it is useful to know the size a structure should be before 
creating it. This is defined as [[foreign-address-size]], 
but it is defined as part of the record definition for 
socket domains below.

\subsection{UNIX Socket Addresses}

<<Exports>>=
unix-address?
make-unix-address
unix-address-path
@

UNIX domain sockets have addresses that are just paths, which in turn are simply strings. 

<<Datatypes>>=
(define-record-type unix-address
  (parent socket-address)
  (protocol
    (lambda (n) (lambda (path) ((n unix-address->foreign) path))))
  (fields path))

@

The protocol uses [[unix-address->foreign]] as the converter 
for a unix address. 
It returns a bytevector that is the equivalent layout
of the sockaddr\_un structure.

<<Datatypes>>=
(define (unix-address->foreign addr) 
  (let ([res (make-bytevector (+ size-of/family unix-max-path) 0)]
        [opath (string->bytevector 
                 (unix-address-path addr)
                 (native-transcoder))])
    (let ([opath-length (bytevector-length opath)])
      (bytevector-uint-set! res 0 af-unix (native-endianness) 
        size-of/family)
      (bytevector-copy! opath 0 res size-of/family
        (if (< unix-max-path opath-length)
            (begin 
              (warning 'unix-address->foreign "Path truncatation!")
              unix-max-path)
            opath-length)))
    res))

@

<<FFI Constants>>=
(af-unix fixnum "int" "AF_UNIX")
(size-of/family fixnum "int" "sizeof(sa_family_t)")
(unix-max-path fixnum "int" 
   "sizeof(x.sun_path)" "struct sockaddr_un x;")
@

<<FFI Headers>>=
<sys/types.h>
<sys/socket.h>
<sys/un.h>
@

Converting the foreign address back to a UNIX address 
can be done by grabbing the vector elements of the range from 
the start of the path to the first null. 

<<Datatypes>>=
(define (foreign->unix-address addr addr-len)
  (let* ([path-len (- (bytevector-sint-ref addr-len 0 
                        (native-endianness) 
                        size-of/integer) 
                      size-of/family)]
         [path (make-bytevector path-len)])
    (bytevector-copy! addr size-of/family path 0 path-len)
    (make-unix-address (bytevector->string path (native-transcoder)))))

@

<<FFI Constants>>=
(size-of/integer fixnum "int" "sizeof(int)")
@

\subsection{IPV4 Internet Socket Addresses}

<<Exports>>=
internet-address?
make-internet-address
internet-address-ip
internet-address-port
string->internet-address
internet-address->string
@

Internet addresses are represented by an IP address and a port number.
The IP address is a bytevector of 4 bytes.
The port number is an integer. The bytevectors are expected to represent 
their addresses using network byte ordering.

<<Datatypes>>=
(define-record-type internet-address 
  (parent socket-address)
  (protocol 
    (lambda (n) (lambda (i p) ((n internet-address->foreign) i p))))
  (fields ip port))

@

Converting the internet-address to a foreign value is done 
by [[internet-address->foreign]].

<<Datatypes>>=
(define (internet-address->foreign addr)
  (let ([res (make-bytevector size-of/addr-in 0)])
    (bytevector-uint-set! res 0 af-inet 
      (native-endianness) 
      size-of/family)
    (bytevector-uint-set! res size-of/family 
      (internet-address-port addr)
      (endianness big)
      size-of/port)
    (bytevector-copy! (internet-address-ip addr) 0
      res (+ size-of/port size-of/family)
      size-of/ip)
    res))

@

<<FFI Constants>>=
(size-of/addr-in fixnum "int" "sizeof(struct sockaddr_in)")
(size-of/port fixnum "int" "sizeof(x.sin_port)"
   "struct sockaddr_in x;")
(size-of/ip fixnum "int" "sizeof(struct in_addr)")
(af-inet fixnum "int" "AF_INET")
@

<<FFI Headers>>=
<netinet/in.h>
@

Converting back is pretty easy.

<<Datatypes>>=
(define (foreign->internet-address addr addr-len)
  (let ([ip (make-bytevector 4)]
        [ipi (+ size-of/family size-of/port)])
    (bytevector-copy! addr ipi ip 0 4)
    (make-internet-address ip
      (bytevector-uint-ref addr size-of/family (endianness big) size-of/port))))

@

Normally, people don't like to provide internet addresses in network 
byte ordered bytevectors. 
Instead, we have two helper procedures that create the structure for us, 
and we define procedures to extract the port and address information 
from the structure.

<<Datatypes>>=
(define string->internet-address
  (lambda (s)
    (define split
      (lambda (s)
        (apply values
          (string-tokenize s
            (char-set-complement (char-set #\:))))))
    (define s->ip
      (lambda (s)
        (apply bytevector
          (map string->number
            (string-tokenize s
              (char-set-complement (char-set #\.)))))))
    (let-values ([(ip-string port-string) (split s)])
      (let ([ip (s->ip ip-string)]
            [port (string->number port-string)])
        (assert (= 4 (bytevector-length ip)))
        (assert (< 0 port 65536))
        (make-internet-address ip port)))))
        
(define internet-address->string
  (lambda (addr)
    (let ([ip (internet-address-ip addr)]
          [port (internet-address-port addr)])
      (assert (< 0 port 65536))
      (assert (= 4 (bytevector-length ip)))
      (format "~{~d~^.~}:~d"
        (bytevector->u8-list ip)
        (internet-address-port addr)))))

@

\section{Address Information}

<<Exports>>=
make-address-info
address-info?
address-info-domain
address-info-type
address-info-protocol
address-info-address
@

The [[get-address-info]] procedure returns a list of [[address-info]] 
structures that specify different means by which a host may be contacted. 

<<Datatypes>>=
(define-record-type address-info (fields domain type protocol address))
@

The [[address]] field of an [[address-info]] record should be an 
internet-socket-address.

\chapter{Socket Constants}

Procedures such as [[create-socket]] accept records which wrap 
numeric constant values for passing into the FFI. 
These constants are limited with what is built in to have the 
widest acceptance and portability, but if the user wishes to use 
more values, he can do so by using the appropriate make form.
This requires that the user know the Operating specific constant 
value that should be used in the FFI.

Every constant type is a child of the [[socket-constant]] type.

<<Datatypes>>=
(define-record-type socket-constant (fields (immutable value)))
@

\chapter{Socket Procedures}

\procsig{[[create-socket]]}{\var{domain} \var{type} \var{protocol}}{\var{socket}}

<<Exports>>=
create-socket
make-socket-domain
make-socket-type
socket-domain/unix socket-domain/local 
socket-domain/internet
socket-type/stream socket-type/datagram
socket-type/sequence-packet socket-type/raw
socket-type/random 
@

\noindent [[create-socket]] corresponds to the [[socket(2)]] system call. 

<<Code>>=
(define (create-socket domain type protocol)
  (assert (and (socket-domain? domain)
               (socket-type? type)
               (socket-protocol? protocol)))
  (let ([ret ($socket (socket-constant-value domain)
                      (socket-constant-value type)
                      (socket-constant-value protocol))])
    (if (negative? ret)
        (ffi-error 'create-socket)
        (make-socket ret domain type protocol))))

@

\noindent [[$socket]] refers directly to the system call:

<<FFI Procedures>>=
(define $socket 
  (foreign-procedure "socket" (fixnum fixnum fixnum) fixnum))
@

[[create-socket]] uses three different constant types for 
the domain, type, and protocol of the socket.

Socket domains determine the family to which the socket belongs. 
They also must embed an extracter and a size value so that 
converting to and from foreign values can be done without 
explicitly knowing the type of the domain beforehand.

<<Constants>>=
(define-record-type (%socket-domain make-socket-domain socket-domain?)
  (parent socket-constant)
  (fields 
    (immutable extractor socket-domain-extractor)
    (immutable addr-size foreign-address-size)))

(define socket-domain/unix
  (make-socket-domain %socket-domain/unix
    foreign->unix-address
    size-of/addr-un))
(define socket-domain/local
  (make-socket-domain %socket-domain/local
    foreign->unix-address
    size-of/addr-un))
(define socket-domain/internet
  (make-socket-domain %socket-domain/internet
    foreign->internet-address
    size-of/addr-in))

@

<<FFI Constants>>=
(%socket-domain/unix fixnum "int" "AF_UNIX")
(%socket-domain/local fixnum "int" "AF_LOCAL")
(%socket-domain/internet fixnum "int" "AF_INET")
(%socket-domain/internet-v6 fixnum "int" "AF_INET6")
(size-of/addr-un fixnum "int" "sizeof(struct sockaddr_un)")
@

Socket types determine the nature of the data stream that 
transmits over the socket. See the [[socket(2)]] man page for 
more details. 

<<Constants>>=
(define-record-type (%socket-type make-socket-type socket-type?)
  (parent socket-constant))

(define socket-type/stream
  (make-socket-type %socket-type/stream))
(define socket-type/datagram
  (make-socket-type %socket-type/datagram))
(define socket-type/sequence-packet
  (make-socket-type %socket-type/sequence-packet))
(define socket-type/raw
  (make-socket-type %socket-type/raw))
(define socket-type/random
  (make-socket-type %socket-type/random))

@

<<FFI Constants>>=
(%socket-type/stream fixnum "int" "SOCK_STREAM")
(%socket-type/datagram fixnum "int" "SOCK_DGRAM")
(%socket-type/sequence-packet fixnum "int" "SOCK_SEQPACKET")
(%socket-type/raw fixnum "int" "SOCK_RAW")
(%socket-type/random fixnum "int" "SOCK_RDM")
@

<<Exports>>=
make-socket-protocol socket-protocol?
protocol-entry-name protocol-entry-aliases protocol-entry-value
@

Dealing with protocol numbers is slightly different, 
since these entries are found in a database that can change, 
rather than in some header file. 

<<Datatypes>>=
(define-record-type (%socket-protocol make-socket-protocol socket-protocol?)
  (parent socket-constant))
@

\noindent Protocols can be retreived by the [[getproto*]] family of 
functions. 
These functions return [[protocol-entry]] structures. 

Generally, however, it is not necessary to use the protocol database, 
and users generally use the default. 
A special case constant is thus provided.

<<Exports>>=
socket-protocol/auto
@

<<Constants>>=
(define socket-protocol/auto (make-socket-protocol 0))

@

<<Datatypes>>=
(define-record-type protocol-entry (fields name aliases value))
@

<<FFI Procedures>>=
(define $getprotoent 
  (foreign-procedure "getprotoent" () uptr))
(define $getprotobyname 
  (foreign-procedure "getprotobyname" (string) uptr))
(define $getprotobynumber
  (foreign-procedure "getprotobynumber" (fixnum) uptr))
(define $setprotoent
  (foreign-procedure "setprotoent" (boolean) void))
(define $endprotoent
  (foreign-procedure "endprotoent" () void))
@

<<Exports>>=
next-protocol-entry
get-protocol-by-name
get-protocol-by-number
open-protocol-database
close-protocol-database
@

<<Constants>>=
(define (next-protocol-entry)
  (foreign->protocol-entry ($getprotoent)))
(define (get-protocol-by-name name)
  (foreign->protocol-entry ($getprotobyname name)))
(define (get-protocol-by-number n)
  (foreign->protocol-entry ($getprotobynumber n)))
(define (open-protocol-database keep-alive?)
  ($setprotoent keep-alive?))
(define (close-protocol-database)
  ($endprotoent))

@

Converting the C structure to the [[protocol-entry]] form 
is performed by the following function [[foreign->protocol-entry]].

<<Constants>>=
(define (protoent-name x) (+ x protoent/name-offset))
(define (protoent-aliases x) (+ x protoent/aliases-offset))
(define (protoent-value x) (+ x protoent/proto-offset))

(define (foreign->string x)
  (let ([v (make-bytevector ($strlen x))])
    ($strcpy v x)
    (bytevector->string v (native-transcoder))))

(define (foreign->integer x)
  (let ([v (make-bytevector size-of/integer)])
    ($strncpy v x size-of/integer)
    (bytevector-sint-ref v 0 (native-endianness) size-of/integer)))

(define (foreign->pointer x)
  (let ([v (make-bytevector size-of/pointer)])
    ($strncpy v x size-of/pointer)
    (bytevector-uint-ref v 0 (native-endianness) size-of/pointer)))

(define (foreign->protocol-entry x)
  (make-protocol-entry
    (foreign->string (foreign->pointer (protoent-name x)))
    (collect-list 
      ([for i  (up-from (foreign->pointer (protoent-aliases x))
                        (by size-of/pointer))]
       [until (zero? ($strlen i))])
      (foreign->string (foreign->pointer i)))
    (make-socket-protocol (foreign->integer (protoent-value x)))))

@

<<FFI Procedures>>=
(define $strcpy
  (foreign-procedure "strcpy" (string uptr) uptr))
(define $strncpy
  (foreign-procedure "strncpy" (string uptr fixnum) uptr))
(define $strlen
  (foreign-procedure "strlen" (uptr) fixnum))
@

<<FFI Constants>>=
(size-of/pointer fixnum "int" "sizeof(char *)")
(protoent/name-offset fixnum "int" 
 "(char *)&x.p_name - (char *)&x"
 "struct protoent x;")
(protoent/aliases-offset fixnum "int" 
 "(char *)&x.p_aliases - (char *)&x"
 "struct protoent x;")
(protoent/proto-offset fixnum "int" 
 "(char *)&x.p_proto - (char *)&x"
 "struct protoent x;")
@

<<FFI Headers>>=
<netdb.h>
@


\procsig{[[bind-socket]]}{\var{socket} \var{socket address}}{}

<<Exports>>=
bind-socket
@

\noindent Corresponds directly to [[bind(2)]]. 

<<Code>>=
(define (bind-socket sock addr)
  (let ([foreign-addr (socket-address->foreign addr)])
    (let ([ret ($bind (socket-fd sock) 
                      foreign-addr 
                      (bytevector-length foreign-addr))])
      (if (zero? ret)
          (void)
          (ffi-error 'bind-socket)))))

@

<<FFI Procedures>>=
(define $bind
  (foreign-procedure "bind" (fixnum string fixnum) fixnum))
@

\procsig{[[listen-socket]]}{\var{socket} \var{queue length}}{}

<<Exports>>=
listen-socket
@

\noindent Corresponds to [[listen(2)]].

<<Code>>=
(define (listen-socket sock queue-length)
  (let ([ret ($listen (socket-fd sock) queue-length)])
    (case ret
      [(0) (void)]
      [(-1) (ffi-error 'listen)]
      [else (error 'listen "Unknown return: ~s" ret)])))

@

<<FFI Procedures>>=
(define $listen
  (foreign-procedure "listen" (fixnum fixnum) fixnum))
@

\procsig{[[accept-socket]]}{\var{socket}}{\var{socket} \var{address}}

<<Exports>>=
accept-socket
@

\noindent Corresponds to [[accept(2)]], but returns both the socket 
and the address as its return values.

<<Code>>=
(define (accept-socket sock)
  (let ([size (foreign-address-size (socket-domain sock))])
    (let ([addr (make-bytevector size 0)]
          [addr-len (make-bytevector size-of/integer 0)])
      (bytevector-sint-set! addr-len 0 size 
        (native-endianness) 
        size-of/integer)
      (let ([ret ($accept (socket-fd sock) addr addr-len)])
        (if (negative? ret) 
            (ffi-error 'accept)
            (values (make-socket ret
                      (socket-domain sock)
                      (socket-type sock)
                      (socket-protocol sock))
              (foreign->socket-address 
                (socket-domain sock) 
                addr 
                addr-len)))))))

@

<<FFI Procedures>>=
(define $accept
  (foreign-procedure "accept" (fixnum string string) fixnum))
@

\procsig{[[connect-socket]]}{\var{socket} \var{address}}{}

<<Exports>>=
connect-socket
@

<<Code>>=
(define (connect-socket sock addr)
  (let ([fa (socket-address->foreign addr)])
    (case ($connect (socket-fd sock) fa (bytevector-length fa))
      [(0) (void)]
      [(-1) (ffi-error 'connect)]
      [else (error 'connect-socket "Unknown foreign return value.")])))

@

<<FFI Procedures>>=
(define $connect
  (foreign-procedure "connect" (fixnum string fixnum) fixnum))
@

\procsig{[[close-socket]]}{\var{socket}}{}

<<Exports>>=
close-socket
@

Equivalent to [[close(2)]].

<<Code>>=
(define (close-socket sock)
  (case ($close (socket-fd sock))
    [(0) (void)]
    [(-1) (ffi-error 'close)]
    [else (error 'close-socket "Unknown foreign return value.")]))

@

<<FFI Procedures>>=
(define $close
  (foreign-procedure "close" (fixnum) fixnum))
@
\procsig{[[shutdown-socket]]}{\var{socket} \var{method}}{}

<<Exports>>=
shutdown-socket
shutdown-method?
make-shutdown-method
shutdown-method/read shutdown-method/write shutdown-method/read&write
@

Corresponds to [[shutdown(s)]].

<<Code>>=
(define (shutdown-socket sock how)
  (assert (shutdown-method? how))
  (case ($shutdown (socket-fd sock) (socket-constant-value how))
    [(0) (void)]
    [(-1) (ffi-error 'shutdown)]
    [else (error 'shutdown-socket "Unknown foreign return value.")]))

@

<<FFI Procedures>>=
(define $shutdown
  (foreign-procedure "shutdown" (fixnum fixnum) fixnum))
@

The shutdown method is a constant value defined as follows.

<<Constants>>=
(define-record-type shutdown-method (parent socket-constant))

(define shutdown-method/read 
  (make-shutdown-method %shutdown/read))
(define shutdown-method/write 
  (make-shutdown-method %shutdown/write))
(define shutdown-method/read&write
  (make-shutdown-method %shutdown/read&write))

@

<<FFI Constants>>=
(%shutdown/write fixnum "int" "SHUT_RD")
(%shutdown/read fixnum "int" "SHUT_WR")
(%shutdown/read&write fixnum "int" "SHUT_RDWR")
@

\procsig{[[socket->port]]}{\var{socket}}{}

<<Exports>>=
socket->port
@

Creates a binary input/ouput port from the socket with the 
socket field descriptor as its id. 

{\it XXX: There must be a more efficient way to implement the 
[[read!]] and [[write!]] procedures here.}

<<Code>>=
(define (socket->port sock)
  (make-custom-binary-input/output-port
    (format "Socket ~a" (socket-fd sock))
    <<Read Socket>>
    <<Write Socket>>
    #f #f 
    <<Close Socket>>))
    
@

We use the [[read(2)]] procedure to handle the reading. 
Since the system [[read]] procedure does not take a position, 
whereas the R6RS [[read!]] procedure is expected to take a 
position, we have to use another intermediate vector, for the 
moment. 

<<Read Socket>>=
(lambda (bv s c)
  (let ([buf (make-bytevector c)])
    (let ([res ($read (socket-fd sock) buf c)])
      (bytevector-copy! buf 0 bv s res)
      res)))
@

<<FFI Procedures>>=
(define $read
  (foreign-procedure "read" (fixnum string fixnum) fixnum))
@

Writing works in mostly the same way, 
except that the R6RS [[write!]] differs from the normal 
[[write(2)]] system call because a zero count write sends 
EOF to the file. 

<<Write Socket>>=
(lambda (bv s c)
  (if (zero? c)
      (let ([res ($write (socket-fd sock)
                   (bytevector (char->integer (eof-character)))
                   1)])
        (cond
          [(= -1 res) (ffi-error 'write)]
          [(negative? res) 
           (error 'socket-write "Unknown foreign return value.")]
          [else res]))
      (let ([buf (make-bytevector c)])
        (bytevector-copy! bv s buf 0 c)
        (let ([res ($write (socket-fd sock) buf c)])
          (cond
            [(= -1 res) (ffi-error 'write)]
            [(negative? res)
             (error 'socket-write "Unknown foreign return value.")]
            [else res])))))
@

<<FFI Procedures>>=
(define $write
  (foreign-procedure "write" (fixnum string fixnum) fixnum))
@

We use the [[eof-character]] parameter to decide what end-of-file 
character to send.

<<Exports>>=
eof-character
@

<<Code>>=
(define eof-character
  (make-parameter #\x4
    (lambda (c)
      (unless (char? c)
        (error 'eof-character "Invalid character" c))
      c)))

@

Closing a socket is the simple matter of using [[close-socket]].

<<Close Socket>>=
(lambda () (close-socket sock))
@

\procsig{[[send-to-socket]]}{\var{socket} \var{buffer} \var{address}}{\var{bytes sent}}

<<Exports>>=
send-to-socket
@

Corresponds to the [[sendto(2)]] system call.

<<Code>>=
(define (send-to-socket sock buf addr . flags)
  (assert (forall send-to-option? flags))
  (let* ([fa (socket-address->foreign addr)]
         [fa-len (bytevector-length fa)]
         [res ($sendto (socket-fd sock) 
                buf (bytevector-length buf)
                (fold-left 
                  (lambda (s v) 
                    (fxior s (socket-constant-value v)))  
                  0 
                  flags)
                fa fa-len)])
    (cond
      [(= -1 res) (ffi-error 'sendto)]
      [(negative? res)
       (error 'send-to-socket "Unknown foreign return value.")]
      [else res])))

@

<<FFI Procedures>>=
(define $sendto
  (foreign-procedure "sendto" 
    (fixnum string fixnum fixnum string fixnum) 
    fixnum))
@

There are a number of system depended flags
that can be passed to [[send-to-socket]],
but only those reasonably portable ones are defined here.

<<Exports>>=
send-to/dont-route send-to/out-of-band
make-send-to-option
@

<<Constants>>=
(define-record-type send-to-option (parent socket-constant))

(define send-to/dont-route
  (make-send-to-option %send-to/dont-route))
(define send-to/out-of-band
  (make-send-to-option %send-to/out-of-band))

@

<<FFI Constants>>=
(%msg/dont-route fixnum "int" "MSG_DONTROUTE")
(%msg/out-of-band fixnum "int" "MSG_OOB")
@

\procsig{[[receive-from-socket]]}
  {\var{socket} \var{count} . \var{flags}}
  {\var{received data} \var{sender address}}

<<Exports>>=
receive-from-socket
@

Corresponds to the system call [[recvfrom(2)]].

{\it XXX: We are doing multiple bytevector copies, and I can't 
see this as a good thing.}

<<Code>>=
(define (receive-from-socket sock c . flags)
  (assert (forall receive-from-option? flags))
  (let ([buf (make-bytevector count)]
        [addr-len (foreign-address-size (socket-domain sock))])
    (let* ([addr (make-bytevector addr-len)]
           [addr-len-buf (make-bytevector size-of/integer)])
      (bytevector-sint-set! addr-len-buf 0 addr-len 
        (native-endianness) size-of/integer)
      (let ([n ($recvfrom (socket-fd sock) buf c 
                 (fold-left
                   (lambda (s v)
                     (fxior s (socket-constant-value v)))
                   0
                   flags)
                 addr addr-len)])
        (cond
          [(= -1 n) (ffi-error 'recvfrom)]
          [(negative? n)
           (error 'receive-from-socket 
             "Unknown foreign return value.")]
          [else
           (values 
             (if (< n c)
                 (let ([res (make-bytevector n)])
                   (bytevector-copy! buf 0 res 0 n)
                   res)
                 buf)
             (foreign->socket-address (socket-domain sock) 
               addr addr-len-buf))])))))

@

<<FFI Procedures>>=
(define $recvfrom
  (foreign-procedure "recvfrom" 
    (fixnum string fixnum fixnum string string)
    fixnum))
@

A few flags are pre-defined.

<<Exports>>=
receive-from/out-of-band receive-from/peek 
receive-from/wait-all receive-from/dontwait
make-receive-from-option
@

<<Constants>>=
(define-record-type receive-from-option (parent socket-constant))

(define receive-from/out-of-band
  (make-receive-from-option %msg/out-of-band))
(define receive-from/peek
  (make-receive-from-option %msg/peek))
(define receive-from/wait-all
  (make-receive-from-option %msg/wait-all))
(define receive-from/dont-wait
  (make-receive-from-option %msg/dont-wait))

@

<<FFI Constants>>=
(%msg/peek fixnum "int" "MSG_PEEK")
(%msg/wait-all fixnum "int" MSG_WAITALL")
(%msg/dont-wait fixnum "int" MSG_DONTWAIT")
@

\procsig{[[socket-maximum-connections]]}{}{\var{integer}}

<<Exports>>=
socket-maximum-connections
@

This is a procedure for accessing the [[SOMAXCONN]] value.

<<Code>>=
(define (socket-maximum-connections)
  %somaxconn)
@

<<FFI Constants>>=
(%somaxconn fixnum "int" "SOMAXCONN")
@

\chapter{Handling FFI Errors}

Error handling for procedures that properly set [[errno]] can be handled 
by a single procedure that calls [[perror]] and signals an exception 
in Scheme.

<<Code>>=
(define ffi-error
  (lambda (who . args)
    ($perror (symbol->string who))
    (apply error `(,who "Error in foreign procedure" ,@args))))

@

<<FFI Procedures>>=
(define $perror (foreign-procedure "perror" (string) void))
@

\chapter{Handling Foreign Constants}

A number of structures have to be converted to and from foreign equivalents. 
The following provides the necessary foreign constants expanded into 
Scheme values at expansion time that are necessary to do these transformations. 

<<Foreign Constants>>=
(define-foreign-constants 
  (<<FFI Headers>>)
  <<FFI Constants>>)
@

\chapter{R6RS Form}

<<sockets.sls>>=
<<License>>

(library (arcfide sockets)
  (export 
    <<Exports>>)
  (import 
    (scheme)
    (riastradh foof-loop)
    (srfi :14)
    (only (srfi :13) string-tokenize)
    (arcfide extended-definitions)
    (arcfide ffi-bind))

<<Foreign Constants>>

<<Datatypes>>

<<FFI Procedures>>

<<Constants>>

<<Code>>

)
@

\chapter{Vanilla File}

\chapter{License}

This sockets library is distributed under an ISC License.

<<License>>=
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Sockets Support for Chez
;;;; Version 1.1 Alpha
;;;
;;; Copyright (c) 2008 - 2009 Aaron Hsu <arcfide@sacrideo.us>
;;; 
;;; Permission to use, copy, modify, and distribute this software for any
;;; purpose with or without fee is hereby granted, provided that the above
;;; copyright notice and this permission notice appear in all copies.
;;; 
;;; THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
;;; WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
;;; MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
;;; ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
;;; WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
;;; ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
;;; OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
@

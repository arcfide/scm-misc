\title{Sockets in Chez Scheme}

\chapter{Introduction}

This is a socket library for Chez Scheme which attempts to remain 
as faithful as possible to BSD sockets while still maintaining a 
normal operation that will be familiar to Scheme programmers.
Procedures are documented inline at the top of their main
definitions. 

The current implementation uses records instead of magic numbers. 
Hopefully this keeps the system a little more portable.
Only Internet and Local/Unix domain sockets are supported 
by this code, though additional types should be relatively easy 
to make.

The code itself is organized into 
new socket datatypes and procedures. 
Each relevant chapter discusses these parts in particular detail.
The constants section describes how to extend the constants 
defined for socket procedures.

The library also includes a C Stub and FFI interface to enable the 
low-level data manipulations and system calls when necessary. 

A build script also accompanies the library to help in the building of 
the code on some platforms. It is only meant as a guide, and may not 
work completely on your system.

\chapter{Uncompleted/Planned Features}

The following is a development to-do list of intended features 
and possible improvements.

\orderedlist
\li Clean up the handling of structures by abstracting and specializing
\li Consider IP field name replaced with ADDRESS
\li Consider name change of RECEIVE-FROM-SOCKET
\li Consider name change of ACCEPT-SOCKET
\li Better handling of paths in UNIX sockets
\endorderedlist

\chapter{Socket Datatypes}

\section{Sockets}

<<Exports>>=
make-socket
socket?
socket-fd
socket-domain
socket-type
socket-protocol
@

Sockets are file descriptors which usually have integer representations. 
The [[socket]] datatype also defines fields for easily determining 
the domain, the type, and the protocol of the socket.

<<Datatypes>>=
(define-record-type socket (fields fd domain type protocol))
@

The [[fd]] field should be a socket field descriptor, which is a positive integer. 
The [[domain]], [[type]], and [[protocol]] fields all contain constants which 
return true for 
[[socket-domain?]], [[socket-type?]], and [[socket-protocol?]], respectively. 
This functionality could be introspected from the field descriptor, but it 
is more convenient to store this information directly.

\section{Socket Options}%
Socket options form a hierarchy of depth two that identify different settings 
for sockets. 

<<Exports>>=
socket-option? make-socket-option socket-option
@

<<Datatypes>>=
(define-record-type socket-option
  (fields level id foreign-size foreign-maker foreign-converter)
  (protocol 
    (lambda (p) 
      (case-lambda 
        [(id size maker converter)  
         (p $sol-socket id size maker converter)] 
        [(id size maker converter level) 
         (p level id size maker converter)]))))

@

<<FFI Constants>>=
($sol-socket int "int" "SOL_SOCKET")
@

\noindent The [[level]] field should be a number identifying the highlevel setting 
group, and [[id]] should be a number identifying the setting itself, as 
described in [[getsockopt(2)]]. 

[[valid?]] is a predicate that returns true for valid setting values, and false otherwise. 

[[make-socket-option]] called without a level will default to a socket api level option, 
otherwise it expects a proper option level. 

\procsig{[[define-socket-option-type]]}{\var{name} \var{level}}{}

<<Exports>>=
define-socket-option-type
@

\noindent Defines a new specific socket-option type with a given \var{level}, which should 
be an integer as detailed in [[setsockopt(2)]]. We use this to define some basic 
socket option levels. This will bind [[name]], [[make-name]], and [[name?]].

<<Datatypes>>=
(define-syntax define-socket-option-type
  (syntax-rules ()
    [(_ name level)
      (define-record-type name (parent socket-option)
        (protocol 
          (lambda (n) 
            (lambda (id size maker converter) 
              ((n id size maker converter level))))))]))

@

\noindent We currently define child option types for the protocols [[tcp(7)]], [[udp(7)]], and [[raw(7)]]. 
I have added the ip option as well because ip options are often applicable to 
the above. 

<<Exports>>=
make-tcp-option make-udp-option make-raw-option make-ip-option
tcp-option? udp-option? raw-option? ip-option? 
@

<<Datatypes>>=
(define-socket-option-type tcp-option $ipproto-tcp)
(define-socket-option-type udp-option $ipproto-udp)
(define-socket-option-type raw-option $ipproto-raw)
(define-socket-option-type ip-option $ipproto-ip)

@

<<FFI Constants>>=
($ipproto-tcp int "int" "IPPROTO_TCP")
($ipproto-udp int "int" "IPPROTO_UDP")
($ipproto-raw int "int" "IPPROTO_RAW")
($ipproto-ip int "int" "IPPROTO_IP")
@

\section{Socket Addresses}

<<Exports>>=
socket-address?
socket-address
@

\noindent Other than sockets, one must also have a means by which to
address other hosts.  Socket Addresses represent the destinations or
origins of transmissions. 

All socket address data types are subtypes of [[socket-address]]es.

<<Datatypes>>=
(define-record-type socket-address (fields converter))
@

\subsection{Converting Socket Addresses}

\noindent When passing socket addresses to foreign procedures, 
we must first convert these Scheme datatypes to a proper foreign socket 
address structure.
To do this, every child of the [[socket-address]] type 
must provide a converter. 
This should be defined by default, and it should not be necessary 
for the user to specify the converter.
The converter should accept the socket address type 
for which it is defined as its sole argument. 
It should then return a bytevector that represents the 
foreign structure. 

Internally, when we need to communicate with a foreign 
procedure that expects a socket address, we use the following 
wrapper.

<<Datatypes>>=
(define (socket-address->foreign sock-addr)
  ((socket-address-converter sock-addr) sock-addr))
@

\noindent If we need to convert an unknown address type into a 
Scheme data structure, we use the following.

<<Datatypes>>=
(define (foreign->socket-address domain addr addr-len)
  ((socket-domain-extractor domain) addr addr-len))
@

\noindent When constructing a bytevector container for foreign code, 
it is useful to know the size a structure should be before 
creating it. This is defined as [[foreign-address-size]], 
but it is defined as part of the record definition for 
socket domains below.

\subsection{UNIX Socket Addresses}

<<Exports>>=
unix-address?
make-unix-address
unix-address-path
@

UNIX domain sockets have addresses that are just paths, which in turn are simply strings. 

<<Datatypes>>=
(define-record-type unix-address
  (parent socket-address)
  (protocol
    (lambda (n) (lambda (path) ((n unix-address->foreign) path))))
  (fields path))

@

\noindent We use [[define-foreign-struct-type]] to define a new type
corresponding to the foreign equivalent of a [[unix-address]], which is
type [[struct sockaddr_un]] in C.

<<Datatypes>>=
<<Define foreign-unix-path>>

(define-foreign-integer-type 
  (sa-family-type make-sa-family get-sa-family sa-family-set!)
  unsigned
  size-of/sa-family
  (native-endianness))

(define-foreign-struct-type foreign-unix-address 
  size-of/sockaddr-un
  (family sa-family-type)
  (path foreign-unix-path))
@

<<FFI Constants>>=
(size-of/sockaddr-un int "int" "sizeof(struct sockaddr_un)")
(size-of/sa-family int "int" "sizeof(sa_family_t)")
@

\noindent A UNIX path is a character array with a maximum size of
[[UNIX_PATH_MAX]]. 

<<Define foreign-unix-path>>=
(define (make-foreign-unix-path x)
  (assert (< 0 (string-length x) unix-max-path))
  (make-foreign-string x))

(define get-foreign-unix-path get-foreign-string)

(define (foreign-unix-path-set! x offset val)
  (assert (< 0 (string-length val) unix-max-path))
  (foreign-string-set! x offset val))

(define-foreign-type foreign-unix-path unix-max-path
  make-foreign-unix-path get-foreign-unix-path foreign-unix-path-set!)
@

The protocol uses [[unix-address->foreign]] as the converter 
for a unix address. 
It returns a bytevector that is the equivalent layout
of the sockaddr\_un structure.

<<Datatypes>>=
(define (unix-address->foreign addr) 
  (make-foreign-unix-address af-unix (unix-address-path addr)))
@

<<FFI Constants>>=
(af-unix fixnum "int" "AF_UNIX")
(unix-max-path fixnum "int" 
   "sizeof(x.sun_path)" "struct sockaddr_un x;")
@

<<FFI Headers>>=
<sys/types.h>
<sys/socket.h>
<sys/un.h>
@

Converting the foreign address back to a UNIX address 
can be done by grabbing the vector elements of the range from 
the start of the path to the first null. 

<<Datatypes>>=
(define (foreign->unix-address addr addr-len)
  (make-unix-address (foreign-unix-address-path addr)))
@

\subsection{IPV4 Internet Socket Addresses}

<<Exports>>=
internet-address?
make-internet-address
internet-address-ip
internet-address-port
string->internet-address
internet-address->string
string->ipv4
@

\noindent Internet addresses are represented by an IP address and a port
number. The highest eight bits of the ip address should be the first
octet of the ip address, and so forth. The port value is a 16-bit
unsigned integer. 

<<Datatypes>>=
(define-record-type internet-address 
  (parent socket-address)
  (protocol 
    (lambda (n) 
      (lambda (i p) ((n internet-address->foreign) i p))))
  (fields ip port))
@

\noindent The foreign equivalent looks like this:

<<Datatypes>>=
<<Define port and ip types>>

(define-foreign-struct-type foreign-ipv4-address
  size-of/sockaddr-in
  (family sa-family-type)
  (port port-type)
  (ip ip-type))
@

\noindent Both of these values are supposed to be translated into
network byte order before being stored in the final structure. 

<<Define port and ip types>>=
(define-foreign-integer-type (port-type make-port get-port port-set!)
  unsigned size-of/port (endianness big))

(define-foreign-integer-type (ip-type make-ip get-ip ip-set!)
  unsigned size-of/ip (endianness big))
@

\noindent Converting the internet-address to a foreign value is done  by
[[internet-address->foreign]].

<<Datatypes>>=
(define (internet-address->foreign addr)
  (make-foreign-ipv4-address
    af-inet
    (internet-address-port addr)
    (internet-address-ip addr)))
@

<<FFI Constants>>=
(size-of/sockaddr-in int "int" "sizeof(struct sockaddr_in)")
(size-of/port fixnum "int" "sizeof(x.sin_port)"
   "struct sockaddr_in x;")
(size-of/ip fixnum "int" "sizeof(struct in_addr)")
(af-inet fixnum "int" "AF_INET")
@

<<FFI Headers>>=
<netinet/in.h>
@

\noindent Converting back is pretty easy.

<<Datatypes>>=
(define (foreign->internet-address addr addr-len)
  (make-internet-address
    (foreign-ipv4-address-ip addr)
    (foreign-ipv4-address-port addr)))
@

\noindent Usually internet addresses are given as a colon delimited ip 
address string and a port number. [[string->internet-address]] converts 
this to a proper internet address structure.

<<Datatypes>>=
(define (string->internet-address s)
  (let-values ([(ip-string port-string) (split-ipv4-address s)])
    (let ([ip (and ip-string (string->ipv4 ip-string))]
          [port (and port-string (string->number port-string))])
      (assert (or (not ip) (>= 32 (bitwise-length ip))))
      (assert (or (not port) (< 0 port 65536)))
      (make-internet-address ip port))))
@

\noindent I define a helper to split the address into ip and port.

<<Datatypes>>=
(define (split-ipv4-address s)
  (let ([val (string-tokenize s (char-set-complement (char-set #\:)))])
    (if (pair? val)
        (values
          (car val)
          (and (pair? (cdr val)) (cadr val)))
        (values #f #f))))
@

\noindent Another helper splits the ip address and converts it to a bytevector 
in big endian or network byte order.

<<Datatypes>>=
(define (string->ipv4 s)
  (let ([bytes (map string->number 
                 (string-tokenize s 
                   (char-set-complement (char-set #\.))))])
    (assert (= 4 (length bytes)))
    (fold-left
      (lambda (s x)
        (assert (<= 0 x 255))
        (+ (bitwise-arithmetic-shift s 8) x))
      0
      bytes)))
@

\noindent The reverse procedure [[internet-address->string]] is more 
straightforward.

<<Datatypes>>=
(define (internet-address->string addr)
  (let (
      [ip (or (internet-address-ip addr) 0)]
      [port (internet-address-port addr)])
    (assert (or (not port) (< 0 port 65536)))
    (assert (>= 32 (bitwise-length ip)))
    (do ([ip ip (bitwise-arithmetic-shift ip -8)]
         [res '() (cons (mod ip 256) res)])
      [(zero? ip)
       (format "~{~d~^.~}~@[:~d~]" res port)])))
@

\section{Address Information}

<<Exports>>=
make-address-info
address-info?
address-info-domain
address-info-type
address-info-protocol
address-info-address
get-address-info
address-info/canonical-name
address-info/numeric-host
address-info/passive
@

\noindent The [[get-address-info]] procedure returns a list of [[address-info]]
structures that specify different means by which a host may be
contacted and a string representing the canonical name of the host if
this information was requested. Otherwise, the second returned value is
false. It corresponds to the [[getaddrinfo(3)]] UNIX system call, with a
few things modified to be more Schemely.

\procsig{[[get-address-info]]}{\var{node} \var{service}
  [\var{domain} \var{type} \var{protocol}] 
  [\var{flags} \dots ]}
  {\var{List of addresses} \var{Canonical Name}}

\noindent Each [[address-info]] structure identifies or associates an
address with a given domain, type, and protocol, which is enough to
create a socket and connect to that address using the right types.

<<Datatypes>>=
(define-record-type address-info (fields domain type protocol address))
@

\noindent The [[address]] field of an [[address-info]] record should be
an  [[internet-socket-address]]. Also note that in the normal C
equivalent of this record type, [[struct addrinfo]], there is also a
field for the canonical name. Because this is given only once, it does
not make sense to have a field for this in every structure that is
returned, so I have decided to place this as an additional value that is
returned by [[get-address-info]] instead, which makes more sense, since
it really is a separate thing to be returned. 

The downside to this approach is that it requires two values to be
accepted when calling [[get-address-info]], even if one does not care
about the canonical name. I am open to better approaches, but this does
not seem to be too inconvenient in practice.

The foreign equivalent, [[struct addrinfo]] can be expressed with
[[define-foreign-struct-type]] and [[define-foreign-integer-type]]. 

We first define a foreign integer type which corresponds to the C
[[int]] type. 

<<Datatypes>>=
(define-foreign-integer-type 
  (foreign-integer 
   make-foreign-integer 
   get-foreign-integer
   foreign-integer-set!)
  signed
  size-of/integer
  (native-endianness))
@

<<FFI Constants>>=
(size-of/integer int "int" "sizeof(int)")
@

\noindent Next we need a [[size_t]] equivalent.

<<Datatypes>>=
(define-foreign-integer-type
  (size-t make-size-t get-size-t size-t-set!)
  unsigned size-of/size-t (native-endianness))
@

<<FFI Constants>>=
(size-of/size-t int "int" "sizeof(size_t)")
@

\noindent And finally, we need some sort of pointer type.

<<Datatypes>>=
(define-foreign-integer-type
  (foreign-pointer 
   make-foreign-pointer 
   get-foreign-pointer
   foreign-pointer-set!)
  unsigned size-of/pointer (native-endianness))
@

<<FFI Constants>>=
(size-of/pointer int "int" "sizeof(void *)")
@

\noindent Then we can define the address info foreign structure.

<<Datatypes>>=
(define-foreign-struct-type foreign-address-info size-of/addrinfo
  (flags foreign-integer)
  (domain foreign-integer)
  (type foreign-integer)
  (protocol foreign-integer)
  (address-length size-t)
  (address foreign-pointer)
  (canonical-name foreign-pointer)
  (next foreign-pointer))
@

<<FFI Constants>>=
(size-of/addrinfo int "int" "sizeof(struct addrinfo)")
@

\noindent [[get-address-info]] takes an optional set of hints, such as
the domain, type, protocol, or a set of flags that can be used to filter
out the results obtained from the call. 

<<Code>>=
(define get-address-info
  (case-lambda
    [(node service)
     (%get-address-info node service #f #f #f '())]
    [(node service dom type proto . flags)
     (%get-address-info node service dom type proto flags)]))
@

\noindent To grab the address we make our foreign buffers, call
[[$getaddrinfo]],  check for errors, and then convert the foreign
address foreign-integero a Scheme structure.

<<Code>>=
(define (%get-address-info node service domain type protocol flags)
  <<Check get-address-info argument types>>
  (let ([addr-list-ptr (make-foreign-pointer 0)]
        [hints (make-addrinfo-hints domain type protocol flags)]
        [service (or (and (string? service) service) 
                     (number->string service 10))])
    (let ([res ($getaddrinfo node service hints addr-list-ptr)])
      (if (zero? res)
          (values 
            (foreign->address-info-list addr-list-ptr)
            ;#f)
            (let ([canon-name 
                    (foreign-address-info-canonical-name
                      (get-foreign-pointer addr-list-ptr 0))])
              (and (not (zero? canon-name))
                   (get-foreign-string canon-name 0))))
          (error 'get-address-info
            "getaddrinfo() failed with code"
            `(code ,res)
            ($gai_strerror res))))))
@

\noindent The optional domain, type, and protocol 
may be false or may correspond to some form of socket options. They are 
used as hints for [[get-address-info]] in the same manner as the 
corresponding hints structure for [[getaddrinfo(2)]]. The flags also 
work in the same way, but they must all be values for which 
[[address-info-option?]] returns true when applied to them.
[[node]] should be a hostname string, and [[service]] should be either 
a service name string, integer number string identifying a valid port, 
or a positive integer representing a valid port.

<<Check get-address-info argument types>>=
(assert (or (not domain) (socket-domain? domain)))
(assert (or (not type) (socket-type? type)))
(assert (or (not protocol) (socket-protocol? protocol)))
(assert (for-all address-info-option? flags))
(assert (string? node))
(assert 
  (or 
    (string? service) 
    (and 
      (integer? service) 
      (positive? service)
      (< 0 service 65536))))
@

<<FFI Procedures>>=
(define $getaddrinfo
  (foreign-procedure "getaddrinfo" (string string string string) int))
(define $gai_strerror
  (foreign-procedure "gai_strerror" (int) string))
@

There are a few built in address info options.

<<Constants>>=
(define-record-type address-info-option (parent socket-constant))

(define address-info/canonical-name
  (make-address-info-option %ai/canonname))
(define address-info/numeric-host
  (make-address-info-option %ai/numerichost))
(define address-info/passive
  (make-address-info-option %ai/passive))
@

<<FFI Constants>>=
(%ai/canonname fixnum "int" "AI_CANONNAME")
(%ai/numerichost fixnum "int" "AI_NUMERICHOST")
(%ai/passive fixnum "int" "AI_PASSIVE")
@

[[make-addrinfo-hints]] converts a domain, type, protocol, 
and set of flags into a [[struct addrinfo]] bytevector.

<<Code>>=
(define (make-addrinfo-hints domain type protocol flags)
  (make-foreign-address-info
    (fold-left
      (lambda (s v)
        (fxior s (socket-constant-value v)))
      0
      flags)
    (or (and domain (socket-constant-value domain)) 0)
    (or (and type (socket-constant-value type)) 0)
    (or (and protocol (socket-constant-value protocol)) 0)
    0
    0
    0
    0))
@

Converting from a foreign [[struct addrinfo]] structure 
to an address information list is done 
with [[foreign->address-info-list]].
This walks through the linked list, grabbing each element from it.

<<Code>>=
(define (foreign->address-info-list alp)
  (do ([ptr (get-foreign-pointer alp 0) (foreign-address-info-next ptr)]
       [res '() (cons (get-address-info-entry ptr) res)])
    [(zero? ptr) (reverse res)]))

(define (get-address-info-entry alp)
  (let ([dom (lookup-domain (foreign-address-info-domain alp))])
    (make-address-info
      dom
      (make-socket-type (foreign-address-info-type alp))
      (make-socket-protocol (foreign-address-info-protocol alp))
      (foreign->socket-address 
        dom
        (foreign-address-info-address alp)
        (foreign-address-info-address-length alp)))))
@
  
\chapter{Socket Constants}

Procedures such as [[create-socket]] accept records which wrap 
numeric constant values for passing into the FFI. 
These constants are limited with what is built in to have the 
widest acceptance and portability, but if the user wishes to use 
more values, he can do so by using the appropriate make form.
This requires that the user know the Operating specific constant 
value that should be used in the FFI.

Every constant type is a child of the [[socket-constant]] type.

<<Datatypes>>=
(define-record-type socket-constant (fields (immutable value)))
@

\chapter{Socket Procedures}

\procsig{[[create-socket]]}{\var{domain} \var{type} \var{protocol}}{\var{socket}}

<<Exports>>=
create-socket
make-socket-domain
make-socket-type
socket-domain/unix socket-domain/local 
socket-domain/internet
socket-type/stream socket-type/datagram
socket-type/sequence-packet socket-type/raw
socket-type/random 
@

\noindent [[create-socket]] corresponds to the [[socket(2)]] system call. 

<<Code>>=
(define (create-socket domain type protocol)
  (assert 
    (and 
      (socket-domain? domain)
      (socket-type? type)
      (socket-protocol? protocol)))
  (call-with-errno 
    (lambda () 
      ($socket
        (socket-constant-value domain)
        (socket-constant-value type)
        (socket-constant-value protocol)))
    (lambda (ret err)
      (if (negative? ret)
        (socket-error 'create-socket 'socket err)
        (let ([sock (make-socket ret domain type protocol)])
          (set-socket-nonblocking! sock #t)
          sock)))))

@

\noindent [[$socket]] refers directly to the system call:

<<FFI Procedures>>=
(define $socket 
  (foreign-procedure "socket" (fixnum fixnum fixnum) fixnum))
@

[[create-socket]] uses three different constant types for 
the domain, type, and protocol of the socket.

Socket domains determine the family to which the socket belongs. 
They also must embed an extracter and a size value so that 
converting to and from foreign values can be done without 
explicitly knowing the type of the domain beforehand.

<<Datatypes>>=
(define-record-type (%socket-domain make-socket-domain socket-domain?)
  (parent socket-constant)
  (fields 
    (immutable extractor socket-domain-extractor)
    (immutable addr-size foreign-address-size)))
@

<<Constants>>=
(define socket-domain/unix
  (make-socket-domain %socket-domain/unix
    foreign->unix-address
    size-of/addr-un))
(define socket-domain/local
  (make-socket-domain %socket-domain/local
    foreign->unix-address
    size-of/addr-un))
(define socket-domain/internet
  (make-socket-domain %socket-domain/internet
    foreign->internet-address
    size-of/addr-in))

@

<<FFI Constants>>=
(%socket-domain/unix fixnum "int" "AF_UNIX")
(%socket-domain/local fixnum "int" "AF_LOCAL")
(%socket-domain/internet fixnum "int" "AF_INET")
(%socket-domain/internet-v6 fixnum "int" "AF_INET6")
(size-of/addr-un fixnum "int" "sizeof(struct sockaddr_un)")
(size-of/addr-in fixnum "int" "sizeof(struct sockaddr_in)")
@

Socket domains sometimes need to be grabbed by just their 
internal value. 
We set up a database to hold the registered domains and 
allow for additional domains to be registered.

<<Exports>>=
register-socket-domain!
@

<<Code>>=
(define socket-domain-db
  (make-parameter '()))

(define (register-socket-domain! domain)
  (assert (socket-domain? domain))
  (let* ([val (socket-constant-value domain)]
         [res (assv val (socket-domain-db))])
    (if res 
        (set-cdr! res domain)
        (socket-domain-db
          (cons (cons val domain) 
                (socket-domain-db))))))

@

We register only the two necessary ones right now.

<<Domain Registration>>=
(register-socket-domain! socket-domain/unix)
(register-socket-domain! socket-domain/internet)
@

We'll want to be able to look these domains up by number.

<<Code>>=
(define (lookup-domain val)
  (let ([res (assv val (socket-domain-db))])
    (and res (cdr res))))
@

Socket types determine the nature of the data stream that 
transmits over the socket. See the [[socket(2)]] man page for 
more details. 

<<Constants>>=
(define-record-type (%socket-type make-socket-type socket-type?)
  (parent socket-constant))

(define socket-type/stream
  (make-socket-type %socket-type/stream))
(define socket-type/datagram
  (make-socket-type %socket-type/datagram))
(define socket-type/sequence-packet
  (make-socket-type %socket-type/sequence-packet))
(define socket-type/raw
  (make-socket-type %socket-type/raw))
(define socket-type/random
  (make-socket-type %socket-type/random))

@

<<FFI Constants>>=
(%socket-type/stream fixnum "int" "SOCK_STREAM")
(%socket-type/datagram fixnum "int" "SOCK_DGRAM")
(%socket-type/sequence-packet fixnum "int" "SOCK_SEQPACKET")
(%socket-type/raw fixnum "int" "SOCK_RAW")
(%socket-type/random fixnum "int" "SOCK_RDM")
@

<<Exports>>=
make-socket-protocol socket-protocol?
protocol-entry-name protocol-entry-aliases protocol-entry-value
@

Dealing with protocol numbers is slightly different, 
since these entries are found in a database that can change, 
rather than in some header file. 

<<Datatypes>>=
(define-record-type (%socket-protocol make-socket-protocol socket-protocol?)
  (parent socket-constant))
@

\noindent Protocols can be retreived by the [[getproto*]] family of 
functions. 
These functions return [[protocol-entry]] structures. 

Generally, however, it is not necessary to use the protocol database, 
and users generally use the default. 
A special case constant is thus provided.

<<Exports>>=
socket-protocol/auto
@

<<Constants>>=
(define socket-protocol/auto (make-socket-protocol 0))

@

For protocol entries, we expect the value to be a protocol constant. 

<<Datatypes>>=
(define-record-type protocol-entry (fields name aliases value))
@

<<FFI Procedures>>=
(define $getprotoent 
  (foreign-procedure "getprotoent" () uptr))
(define $getprotobyname 
  (foreign-procedure "getprotobyname" (string) uptr))
(define $getprotobynumber
  (foreign-procedure "getprotobynumber" (fixnum) uptr))
(define $setprotoent
  (foreign-procedure "setprotoent" (boolean) void))
(define $endprotoent
  (foreign-procedure "endprotoent" () void))
@

<<Exports>>=
next-protocol-entry
get-protocol-by-name
get-protocol-by-constant
open-protocol-database
close-protocol-database
@

Each of the general protocol retreival functions that utilize [[foreign->protocol-entry]] 
will return false when they are at the end of the protocols database or if there was an error. 

<<Constants>>=
(define (next-protocol-entry)
  (foreign->protocol-entry ($getprotoent)))
(define (get-protocol-by-name name)
  (foreign->protocol-entry ($getprotobyname name)))
(define (get-protocol-by-constant proto)
  (foreign->protocol-entry 
    ($getprotobynumber (socket-constant-value proto))))
(define (open-protocol-database keep-alive?)
  ($setprotoent keep-alive?))
(define (close-protocol-database)
  ($endprotoent))

@

The foreign protocol structure has the following definition:

\medskip\verbatim
struct protoent {
  char *p_name;
  char **p_aliases;
  int p_proto;
}
|endverbatim
\medskip

\noindent Which we convert to the following foreign struct type.

<<Constants>>=
(define-foreign-struct-type foreign-protocol-entry size-of/protoent
  (name foreign-pointer)
  (aliases foreign-pointer)
  (protocol foreign-integer))
@

<<Exports>>=
foreign-protocol-entry-name
foreign-protocol-entry-aliases
foreign-protocol-entry-protocol
get-foreign-pointer
@

\noindent [[foreign->protocol-entry]] converts the foreign value into
the normal [[protocol-entry]]. 

<<Constants>>=
(trace-define (foreign->protocol-entry x)
  (make-protocol-entry
    (get-foreign-string (foreign-protocol-entry-name x) 0)
    (do ([ptr (foreign-protocol-entry-aliases x) 
              (+ ptr size-of/pointer)]
         [res '() (cons (get-foreign-string ptr 0) res)])
      [(zero? (get-foreign-pointer ptr 0)) (reverse res)])
    (foreign-protocol-entry-protocol x)))
@

<<FFI Constants>>=
(size-of/protoent int "int" "sizeof(struct protoent)")
@

Converting the C structure to the [[protocol-entry]] form 
is performed by the following function [[foreign->protocol-entry]].
All of the foreign converters here expect pointers.

{\it XXX: this should really be abstracted into a general structure 
introspection library so that each implementation can handle this 
in its own way.}

<<Old Constants>>=
(define (protoent-name x) (+ x protoent/name-offset))
(define (protoent-aliases x) (+ x protoent/aliases-offset))
(define (protoent-value x) (+ x protoent/proto-offset))

(define (foreign->string x)
  (let ([v (make-bytevector ($strlen x))])
    ($strcpy v x)
    (bytevector->string v (native-transcoder))))

(define (foreign->integer x)
  (let ([v (make-bytevector size-of/integer)])
    ($memcpy v x size-of/integer)
    (bytevector-sint-ref v 0 (native-endianness) size-of/integer)))

(define (foreign->pointer x)
  (let ([v (make-bytevector size-of/pointer)])
    ($memcpy v x size-of/pointer)
    (bytevector-uint-ref v 0 (native-endianness) size-of/pointer)))

@

\noindent The explicit check for the null pointer return takes place below. 

<<Old Constants>>=
(define (foreign->protocol-entry x)
  (if (zero? x) #f
    (make-protocol-entry
      (foreign->string (foreign->pointer (protoent-name x)))
      (do (
          [i (foreign->pointer (protoent-aliases x)) (+ i size-of/pointer)]
          [res '() (cons (foreign->string (foreign->pointer i)) res)])
        [(zero? ($strlen i)) (reverse res)])
      (make-socket-protocol (foreign->integer (protoent-value x))))))
@

<<Old FFI Procedures>>=
(define $strcpy
  (foreign-procedure "strcpy" (string uptr) uptr))
(define $strlen
  (foreign-procedure "strlen" (uptr) fixnum))
@

<<Old FFI Constants>>=
(protoent/name-offset fixnum "int" 
 "(char *)&x.p_name - (char *)&x"
 "struct protoent x;")
(protoent/aliases-offset fixnum "int" 
 "(char *)&x.p_aliases - (char *)&x"
 "struct protoent x;")
(protoent/proto-offset fixnum "int" 
 "(char *)&x.p_proto - (char *)&x"
 "struct protoent x;")
@

<<FFI Headers>>=
<netdb.h>
@


\procsig{[[bind-socket]]}{\var{socket} \var{socket address}}{}

<<Exports>>=
bind-socket
@

\noindent Corresponds directly to [[bind(2)]]. 

<<Code>>=
(define (bind-socket sock addr)
  (let ([foreign-addr (socket-address->foreign addr)])
    (call-with-errno
      (lambda () ($bind (socket-fd sock) foreign-addr (bytevector-length foreign-addr)))
      (lambda (ret err) (if (zero? ret) (void) (socket-error 'bind-socket 'bind err))))))

@

<<FFI Procedures>>=
(define $bind
  (foreign-procedure "bind" (fixnum string fixnum) fixnum))
@

\procsig{[[listen-socket]]}{\var{socket} \var{queue length}}{}

<<Exports>>=
listen-socket
@

\noindent Corresponds to [[listen(2)]].

<<Code>>=
(define (listen-socket sock queue-length)
  (call-with-errno (lambda () ($listen (socket-fd sock) queue-length))
    (lambda (ret err)
      (case ret
        [(0) (void)]
        [(-1) (socket-error 'listen-socket 'listen err)]
        [else (error 'listen "Unknown return" ret)]))))

@

<<FFI Procedures>>=
(define $listen
  (foreign-procedure "listen" (fixnum fixnum) fixnum))
@

\procsig{[[accept-socket]]}{\var{socket}}{\var{socket} \var{address}}

<<Exports>>=
accept-socket
@

\noindent Corresponds to [[accept(2)]], but returns both the socket 
and the address as its return values.

<<Code>>=
(define (accept-socket sock)
  (let ([size (foreign-address-size (socket-domain sock))])
    (let (
        [addr (make-bytevector size 0)]
        [addr-len (make-bytevector size-of/integer 0)])
      (bytevector-sint-set! addr-len 0 size 
        (native-endianness) 
        size-of/integer)
      (call-with-errno (lambda () ($accept (socket-fd sock) addr addr-len))
        (lambda (ret err)
          (if (negative? ret) 
            (values #f 
              (socket-raise/unless 'accept-socket 'accept err
                $error-again $error-would-block))
            (values 
              (make-socket ret
                (socket-domain sock)
                (socket-type sock)
                (socket-protocol sock))
              (foreign->socket-address 
                (socket-domain sock) 
                addr 
                addr-len))))))))

@

<<FFI Procedures>>=
(define $accept
  (foreign-procedure "accept" (fixnum string string) fixnum))
@

<<FFI Headers>>=
<errno.h>
@

<<FFI Constants>>=
($error-again fixnum "int" "EAGAIN")
($error-would-block fixnum "int" "EWOULDBLOCK")
@

\procsig{[[connect-socket]]}{\var{socket} \var{address}}{}

<<Exports>>=
connect-socket
@

<<Code>>=
(define (connect-socket sock addr)
  (let ([fa (socket-address->foreign addr)])
    (call-with-errno (lambda () ($connect (socket-fd sock) fa (bytevector-length fa)))
      (lambda (ret err)
        (case ret
          [(0) (void)]
          [(-1) (socket-raise/unless 'connect-socket 'connect err $error-in-progress)]
          [else (error 'connect-socket "Unknown foreign return value.")])))))
    

@

<<FFI Procedures>>=
(define $connect
  (foreign-procedure "connect" (fixnum string fixnum) fixnum))
@

<<FFI Constants>>=
($error-in-progress fixnum "int" "EINPROGRESS")
@

\procsig{[[close-socket]]}{\var{socket}}{}

<<Exports>>=
close-socket
@

Equivalent to [[close(2)]].

<<Code>>=
(define (close-socket sock)
  (call-with-errno (lambda () ($close (socket-fd sock)))
    (lambda (ret err)
      (case ret
        [(0) (void)]
        [(-1) (socket-error 'close-socket 'close err)]
        [else (error 'close-socket "Unknown foreign return value.")]))))

@

<<FFI Procedures>>=
(define $close
  (foreign-procedure "close" (fixnum) fixnum))
@
\procsig{[[shutdown-socket]]}{\var{socket} \var{method}}{}

<<Exports>>=
shutdown-socket
shutdown-method?
make-shutdown-method
shutdown-method/read shutdown-method/write shutdown-method/read&write
@

Corresponds to [[shutdown(s)]].

<<Code>>=
(define (shutdown-socket sock how)
  (assert (shutdown-method? how))
  (call-with-errno (lambda () ($shutdown (socket-fd sock) (socket-constant-value how)))
    (lambda (ret err)
      (case ret
        [(0) (void)]
        [(-1) (socket-error 'shutdown-socket 'shutdown err)]
        [else (error 'shutdown-socket "Unknown foreign return value.")]))))
  

@

<<FFI Procedures>>=
(define $shutdown
  (foreign-procedure "shutdown" (fixnum fixnum) fixnum))
@

The shutdown method is a constant value defined as follows.

<<Constants>>=
(define-record-type shutdown-method (parent socket-constant))

(define shutdown-method/read 
  (make-shutdown-method %shutdown/read))
(define shutdown-method/write 
  (make-shutdown-method %shutdown/write))
(define shutdown-method/read&write
  (make-shutdown-method %shutdown/read&write))

@

<<FFI Constants>>=
(%shutdown/write fixnum "int" "SHUT_RD")
(%shutdown/read fixnum "int" "SHUT_WR")
(%shutdown/read&write fixnum "int" "SHUT_RDWR")
@

\procsig{[[send-to-socket]]}{\var{socket} \var{buffer} \var{address}}{\var{bytes sent}}

<<Exports>>=
send-to-socket
@

Corresponds to the [[sendto(2)]] system call.

<<Code>>=
(define (send-to-socket sock buf addr . flags)
  (assert (for-all send-to-option? flags))
  (let* (
      [fa (socket-address->foreign addr)]
      [fa-len (bytevector-length fa)])
    (call-with-errno 
      (lambda () 
        ($sendto (socket-fd sock) buf (bytevector-length buf)
          (fold-left  (lambda (s v) (fxior s (socket-constant-value v))) 0 flags)
          fa fa-len))
      (lambda (res err)
        (cond
          [(= -1 res) 
            (socket-raise/unless 'send-to-socket 'sendto err
              $error-again $error-would-block)]
          [(negative? res)
            (error 'send-to-socket "Unknown foreign return value.")]
          [else res])))))

@

<<FFI Procedures>>=
(define $sendto
  (foreign-procedure "sendto" 
    (fixnum string fixnum fixnum string fixnum) 
    fixnum))
@

There are a number of system depended flags
that can be passed to [[send-to-socket]],
but only those reasonably portable ones are defined here.

<<Exports>>=
send-to/dont-route send-to/out-of-band
make-send-to-option
@

<<Constants>>=
(define-record-type send-to-option (parent socket-constant))

(define send-to/dont-route
  (make-send-to-option %msg/dont-route))
(define send-to/out-of-band
  (make-send-to-option %msg/out-of-band))

@

<<FFI Constants>>=
(%msg/dont-route fixnum "int" "MSG_DONTROUTE")
(%msg/out-of-band fixnum "int" "MSG_OOB")
@

\procsig{[[receive-from-socket]]}
  {\var{socket} \var{count} . \var{flags}}
  {\var{received data} \var{sender address}}

<<Exports>>=
receive-from-socket
@

Corresponds to the system call [[recvfrom(2)]].

{\it XXX: We are doing multiple bytevector copies, and I can't 
see this as a good thing.}

<<Code>>=
(define (receive-from-socket sock c . flags)
  (assert (for-all receive-from-option? flags))
  (let (
      [buf (make-bytevector c)]
      [addr-len (foreign-address-size (socket-domain sock))])
    (let* (
        [addr (make-bytevector addr-len)]
        [addr-len-buf (make-bytevector size-of/integer)])
      (bytevector-sint-set! addr-len-buf 0 addr-len 
        (native-endianness) size-of/integer)
      (call-with-errno
        (lambda ()
          ($recvfrom (socket-fd sock) buf c 
            (fold-left (lambda (s v) (fxior s (socket-constant-value v))) 0 flags)
            addr addr-len))
        (lambda (n err)
          (cond
            [(= -1 n) 
              (socket-raise/unless 'receive-from-socket 'recvfrom err
                $error-again $error-would-block)]
            [(negative? n) (error 'receive-from-socket "Unknown foreign return value.")]
            [else
              (values 
                (if (< n c)
                  (let ([res (make-bytevector n)])
                    (bytevector-copy! buf 0 res 0 n)
                    res)
                  buf)
                (foreign->socket-address (socket-domain sock) 
                  addr addr-len-buf))]))))))

@

<<FFI Procedures>>=
(define $recvfrom
  (foreign-procedure "recvfrom" 
    (fixnum string fixnum fixnum string string)
    fixnum))
@

A few flags are pre-defined.

<<Exports>>=
receive-from/out-of-band receive-from/peek 
receive-from/wait-all receive-from/dont-wait
make-receive-from-option
@

<<Constants>>=
(define-record-type receive-from-option (parent socket-constant))

(define receive-from/out-of-band
  (make-receive-from-option %msg/out-of-band))
(define receive-from/peek
  (make-receive-from-option %msg/peek))
(define receive-from/wait-all
  (make-receive-from-option %msg/wait-all))
(define receive-from/dont-wait
  (make-receive-from-option %msg/dont-wait))

@

<<FFI Constants>>=
(%msg/peek fixnum "int" "MSG_PEEK")
(%msg/wait-all fixnum "int" "MSG_WAITALL")
(%msg/dont-wait fixnum "int" "MSG_DONTWAIT")
@

\procsig{[[socket-maximum-connections]]}{}{\var{integer}}

<<Exports>>=
socket-maximum-connections
@

This is a procedure for accessing the [[SOMAXCONN]] value.

<<Code>>=
(define (socket-maximum-connections)
  %somaxconn)
@

<<FFI Constants>>=
(%somaxconn fixnum "int" "SOMAXCONN")
@

\procsig{[[get-socket-option]]}{\var{socket} \var{socket option}}{\var{value}}

<<Exports>>=
get-socket-option
@

\noindent Correlates to the use of [[getsockopt(2)]], but with a slightly different interface. 
See the above chapter on Socket Options for the format of socket options. 

<<Code>>=
(define (get-socket-option sock opt)
  (let ([len (socket-option-foreign-size opt)])
    (let ([fbuf (make-bytevector len)] [flen (make-bytevector size-of/socklen-t)])
      (bytevector-uint-set! flen 0 len (native-endianness) size-of/socklen-t)
      (call-with-errno
        (lambda () 
          ($getsockopt (socket-fd sock) 
            (socket-option-level opt)
            (socket-option-id opt)
            fbuf flen))
        (lambda (ret err)
          (when (negative? ret)
            (socket-error 'get-socket-option 'getsockopt err))
          ((socket-option-foreign-converter opt)
            fbuf
            (bytevector-uint-ref flen 0 (native-endianness) size-of/socklen-t)))))))
@

<<FFI Procedures>>=
(define $getsockopt
  (foreign-procedure "getsockopt" (int int int string string) int))
@

<<FFI Constants>>=
(size-of/socklen-t int "int" "sizeof(socklen_t)")
@

\procsig{[[set-socket-option!]]}{\var{socket} \var{socket option} \var{value}}{}

<<Exports>>=
set-socket-option!
@

\noindent Sets the \var{socket option} of the given \var{socket} to \var{value}. See 
[[setsockopt(2)]] for more information. The interface is more Schemely, but the overall 
approach is the same. 

<<Code>>=
(define (set-socket-option! sock opt val)
  (call-with-errno
    (lambda ()
      (let ([buf ((socket-option-foreign-maker opt) val)])
        ($setsockopt
          (socket-fd sock)
          (socket-option-level opt)
          (socket-option-id opt)
          buf (bytevector-length buf))))
    (lambda (ret err)
      (when (negative? ret)
        (socket-error 'set-socket-option! 'setsockopt err))
      (void))))

@

<<FFI Procedures>>=
(define $setsockopt
  (foreign-procedure "setsockopt" (int int int string int) int))
@

\chapter{Blocking Sockets}%
The following options allow you to determine if a socket is blocking or non-blocking and 
set the nonblocking state of the socket. Use of these options is not recommended or 
encouraged. They exist here for implementing some low-level behavior for higher 
level abstractions.

<<Exports>>=
set-socket-nonblocking!
socket-nonblocking?
@

<<Code>>=
(define (set-socket-nonblocking! sock val)
  (call-with-errno 
    (lambda () 
      (if val 
        ($fcntl (socket-fd sock) $file-set-flag $option-non-blocking) 
        ($fcntl (socket-fd sock) $file-set-flag 0)))
    (lambda (ret err)
      (when (negative? ret)
        (socket-error 'set-socket-nonblocking! 'fcntl err)))))

(define (socket-nonblocking? sock)
  (not (zero? (fxand $option-non-blocking ($fcntl (socket-fd sock) $file-get-flag 0)))))

@

<<FFI Headers>>=
<sys/unistd.h>
<sys/fcntl.h>
@

<<FFI Procedures>>=
(define $fcntl
  (foreign-procedure "fcntl" (fixnum fixnum fixnum) fixnum))
@

<<FFI Constants>>=
($file-set-flag fixnum "int" "F_SETFL")
($file-get-flag fixnum "int" "F_GETFL")
($option-non-blocking fixnum "int" "O_NONBLOCK")
@

\chapter{Handling Socket Errors}

<<Exports>>=
make-socket-condition socket-condition?
socket-condition-who 
socket-condition-syscall
socket-condition-type
socket-condition-message
@

Most of the underlying system calls in this library signal an error with some value and 
then set [[errno]]. Most of these errors should be raised, but on system calls that could 
block, would don't because a socket has been set to non-blocking, we should not do so.

Generally, I leave how to raise or return the error up to the individual functions. However, 
all of them need a nice way to obtain a given Scheme condition rather than some obscure 
error number. 

<<Conditions>>=
(define-condition-type &socket &condition make-socket-condition socket-condition?
  (who socket-condition-who)
  (syscall socket-condition-syscall)
  (type socket-condition-type)
  (msg socket-condition-message))
@

For functions that want to raise an error regardless of the return type, they can use 
[[socket-error]].

<<Exports>>=
socket-error socket-raise/unless
@

<<Code>>=
(define (socket-error who call errval)
  (raise (make-socket-condition who call errval (errno-message errval))))

@

Some functions, however, may want to return the conditions instead of raising the 
error. The following provides this functionality.

<<Code>>=
(define (socket-raise/unless who call errval . vals)
  (let ([cnd (make-socket-condition who call errval (errno-message errval))])
    (if (memv (socket-condition-type cnd) vals) cnd (raise cnd))))

@

\chapter{Handling Foreign Constants}

A number of structures have to be converted to and from foreign equivalents. 
The following provides the necessary foreign constants expanded into 
Scheme values at expansion time that are necessary to do these transformations. 

<<Foreign Constants>>=
(define-foreign-constants 
  (<<FFI Headers>>)
  <<FFI Constants>>)
@

\chapter{R6RS Form}

<<sockets.sls>>=
<<License>>

(library (arcfide sockets)
  (export 
    <<Exports>>)
  (import 
    (rnrs base)
    (rnrs bytevectors)
    (rnrs records syntactic)
    (rnrs io ports)
    (rnrs control)
    (rnrs conditions)
    (rnrs arithmetic fixnums)
    (rnrs arithmetic bitwise)
    (rnrs lists)
    (rnrs mutable-pairs)
    (rnrs exceptions)
    (srfi :14)
    (srfi :39 parameters)
    (only (srfi :13) string-tokenize)
    (arcfide ffi-bind)
    (arcfide errno)
    (arcfide ffi-bind types)
    (only (chezscheme) foreign-procedure format trace-define void))

<<Foreign Constants>>

<<Datatypes>>

<<Conditions>>

<<FFI Procedures>>

<<Constants>>

<<Code>>

<<Domain Registration>>

)
@

\chapter{Vanilla File}

<<sockets.scm>>=
<<License>>

<<Foreign Constants>>

<<Datatypes>>

<<Conditions>>

<<FFI Procedures>>

<<Constants>>

<<Code>>

<<Domain Registration>>
@

\chapter{License}

This sockets library is distributed under an ISC License.

<<License>>=
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Sockets Support for Chez
;;;; Version 1.2
;;;
;;; Copyright (c) 2008 - 2009 Aaron Hsu <arcfide@sacrideo.us>
;;; 
;;; Permission to use, copy, modify, and distribute this software for any
;;; purpose with or without fee is hereby granted, provided that the above
;;; copyright notice and this permission notice appear in all copies.
;;; 
;;; THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
;;; WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
;;; MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
;;; ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
;;; WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
;;; ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
;;; OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
@

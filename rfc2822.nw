\title{RFC 2822 Message Parsing}

\chapter{Introduction}
RFC 2822 is the latest internet messaging standard 
that supercedes the traditional RFC 822.
This manual documents the implementation of a library 
for parsing and using RFC 2822 compliant messages.
It is implemented in Chez Scheme
and closely follows the organization of the RFC 
for easy navigation.

\chapter{Module Declaration and General Layout}
The implementation divides roughly into Datatype declarations, 
utilities that are not part of the RFC,
Tokenization, or low-level lexical parsing,
Field Parsing,
and Message Parsing. 
When an exported procedure is defined, 
an appropriate export chunk will accompany it.
When a procedure is used for the first time in this document,
an import chunk will import the appropriate libraries 
if they have not already been imported previously in the document.

<<rfc2822.sls>>=
<<License>>

(library (arcfide rfc2822)
	(export <<Exports>>)
	(import (rnrs base)
		<<Imports>>)

<<Datatypes>>

<<Utilities>>

<<Tokenization>>

<<Field Parsing>>

<<Message Parsing>>

<<Obsolete>>

<<Convenience Procedures>>

)
@

\chapter{Convenience Procedures}%

<<Exports>>=
parse-rfc2822-message rfc2822-transcoder
@

<<Convenience Procedures>>=
<<Transcoder>>

(define parse-rfc2822-message
	(make-generic-parser rfc2822-parser:message rfc2822-transcoder))
@

All RFC2822 parsers expect streams without any newline modification, 
so we make a transcoder to help people get their input streams 
right.

<<Imports>>=
(rnrs io ports)
@

<<Transcoder>>=
(define rfc2822-transcoder
	(make-transcoder (utf-8-codec) (eol-style none)))
@

\chapter{Documentation Format}

Exported procedures will be documented in the following format:

\procsig{[[procedure-name]]}{\var{input-args} {\it\dots}}{\var{return-value}}

\chapter{Low-level Pre-processing and Tokenization}
RFC 2822 3.2 defines a series of lexical tokens 
which are used in later, higher-level parsers. 
These are used in structured field bodies. 
Higher level parsers are defined in terms of these lower-level tokens, 
and take streams of these tokens, rather than dealing explicitly 
with streams of characters.

\section{Character Classes (RFC 2822 3.2.1)}

<<Imports>>=
(srfi :14)
(riastradh parscheme)
@

The RFC defines a series of parsers for low level character classing. 
These may or may not be used by the future parsers, but are defined 
here just in case. 

{\it XXX: Decide whether these are actually needed.}

<<Exports>>=
rfc2822-parser:text
@

<<Tokenization>>=
(define-parser rfc2822-parser:no-ws-ctl
	(parser:char-in-set
		(char-set-union
			(ucs-range->char-set 1 8)
			(char-set (integer->char 11))
			(char-set (integer->char 12))
			(ucs-range->char-set 14 31)
			(char-set (integer->char 127)))))

(define-parser rfc2822-parser:text
	(parser:choice
		(parser:char-in-set
			(char-set-difference char-set:full (char-set #\return #\linefeed)))
		obs-text))

(define-parser rfc2822-parser:specials
	(parser:char-in-set
		(char-set #\( #\) #\< #\> #\[ #\] #\: #\; #\@ #\\ #\, #\. #\")))

@

\section{Quoted Characters (RFC 3.2.2)}
Quoted characters are characters that would normally not be valid 
except for their being escaped by a backslash character.

<<Tokenization>>=
(define-parser rfc2822-parser:quoted-pair
	(parser:choice 
		(parser:sequence (parser:char= #\\) rfc2822-parser:text)
		obs-qp))

@

\section{Whitespace and Comments (RFC 3.2.3)}
Whitespace and comments semantically have meaning 
no further than that of a single space. 
However, since a comment is usually intended 
for some human to read it, 
the following parsers will maintain the information in comments. 

These parsers return lists of strings and lists,
which contain the comment text.
If no comments were found, and only whitespace exists, 
then nil is returned.

The RFC doesn't give an explicit parser for CRLF and WSP, 
but this is useful.

<<Exports>>=
rfc2822-parser:crlf
@

<<Utilities>>=
(define-parser rfc2822-parser:crlf
	(parser:sequence 
		(parser:char= #\return)
		(parser:char= #\linefeed)))

(define-parser rfc2822-parser:wsp
	(parser:char-in-set (char-set #\space #\tab)))
	
(define-parser rfc2822-parser:alpha
	(parser:char-in-set char-set:letter))

(define-parser rfc2822-parser:digit
	(parser:char-in-set char-set:digit))

@

The RFC defines two main whitespace targets: FWS and CFWS.

<<Exports>>=
rfc2822-parser:cfws-opt
@

<<Imports>>=
(arcfide parser-util)
@

<<Tokenization>>=
(define-parser rfc2822-parser:fws
	(parser:deep-choice
		(*parser [s1 (parser:string:repeated rfc2822-parser:wsp)]
						 [rfc2822-parser:crlf]
						 [s2 (parser:string:at-least 1 rfc2822-parser:wsp)]
			(parser:return (string-append s1 s2)))
		(parser:string:at-least 1 rfc2822-parser:wsp)
		obs-fws))

(define %fws-opt (parser:optional #f rfc2822-parser:fws))

(define-parser rfc2822-parser:ctext
	(parser:char-in-set
		(char-set-difference char-set:full
			(char-set #\nul #\return #\linefeed #\tab #\space)
			(char-set #\( #\) #\\))))

(define-parser rfc2822-parser:ccontent
	(parser:string:at-least 1
		(parser:choice rfc2822-parser:ctext rfc2822-parser:quoted-pair)))

(define-parser rfc2822-parser:comment
	(parser:bracketed-list (parser:char= #\() (parser:char= #\))
		(parser:choice rfc2822-parser:comment
			(parser:string:append:repeated
				(parser:choice rfc2822-parser:fws rfc2822-parser:ccontent)))))

(define-parser rfc2822-parser:cfws
	(parser:sequence 
		(parser:list:repeated
			(parser:backtrackable 
				(parser:sequence %fws-opt rfc2822-parser:comment)))
		(parser:deep-choice
			(parser:sequence %fws-opt rfc2822-parser:comment)
			rfc2822-parser:fws)))

(define rfc2822-parser:cfws-opt (parser:optional #f rfc2822-parser:cfws))

@

\subsection{Obsolete Folding Whitespace (4.2)}

<<Obsolete>>=
(define-parser obs-fws
	(*parser [s1 (parser:string:at-least 1 rfc2822-parser:wsp)]
					 [rest (parser:string:repeated 
									 (parser:sequence
										 rfc2822-parser:crlf
										 (parser:string:at-least 1 rfc2822-parser:wsp)))]
		(parser:return (string-append s1 rest))))

@

\section{Atoms (RFC 3.2.4)}
Atoms are just small units of basic text without controls, wsp, or specials.
The RFC defines a dot atom production for times when runs of atoms may have 
a period between them.
Atoms are returned as strings.

<<Imports>>=
(rnrs lists)
@

<<Tokenization>>=
(define-parser rfc2822-parser:atext
	(parser:char-in-set
		(char-set-difference char-set:full
			char-set:iso-control
			(char-set #\space #\tab #\nul #\( #\) #\< #\> #\[ #\] 
				#\: #\; #\@ #\\ #\, #\. #\"))))

(define-parser %1*atext
	(parser:string:at-least 1 rfc2822-parser:atext))

(define-parser rfc2822-parser:atom
	(parser:single-bracketed rfc2822-parser:cfws-opt %1*atext))

(define-parser rfc2822-parser:dot-atom-text
	(*parser [s1 %1*atext]
					 [rest (parser:list:repeated
									 (parser:sequence (parser:char= #\.) %1*atext))]
		(parser:return 
			(fold-left (lambda (x y) (string-append x "." y)) s1 rest))))

(define-parser rfc2822-parser:dot-atom
	(parser:single-bracketed rfc2822-parser:cfws-opt rfc2822-parser:dot-atom-text))

@

\section{Quoted Strings (RFC 3.2.5)}
Quoted strings allows a stream of text to be considered as one unit, 
such as when this text can not be expressed with just the atom syntax. 
A Quoted String can be folded, and is treated as a single unit 
modulo quote characters and surrounding CWFS.

<<Exports>>=
rfc2822-parser:quoted-string
@

<<Tokenization>>=
(define-parser rfc2822-parser:qtext
	(parser:char-in-set
		(char-set-difference char-set:full
			(char-set #\nul #\return #\linefeed #\tab #\space #\\ #\"))))

(define-parser rfc2822-parser:qcontent
	(parser:string:at-least 1
		(parser:choice rfc2822-parser:qtext rfc2822-parser:quoted-pair)))

(define-parser rfc2822-parser:quoted-string
	(parser:bracketed
		(parser:sequence rfc2822-parser:cfws-opt (parser:char= #\"))
		(parser:sequence (parser:char= #\") rfc2822-parser:cfws-opt)
		(parser:string:append:repeated
			(parser:choice rfc2822-parser:fws rfc2822-parser:qcontent))))

@

\section{Miscellaneous Tokens (RFC 3.2.6)}
As well as providing convenience parsers defined in the RFC for handling 
runs of quoted strings and atoms. 

<<Tokenization>>=
(define-parser rfc2822-parser:word
	(parser:deep-choice rfc2822-parser:atom rfc2822-parser:quoted-string))
	
(define-parser rfc2822-parser:phrase
	(parser:deep-choice
		(parser:list:at-least 1 rfc2822-parser:word)
		obs-phrase))

@

It is also necessary to parse unstructured fields, 
which do not have the same tokenization as above.
In particular, white space and comments are not collapsed. 

<<Exports>>=
rfc2822-parser:unstructured
@

<<Tokenization>>=
(define-parser rfc2822-parser:utext
	(parser:choice 
		(parser:char-in-set
			(char-set-difference char-set:full
				(char-set #\nul #\return #\linefeed #\tab #\space)))
		obs-utext))

#;(define-parser rfc2822-parser:unstructured
	(parser:string:at-least-until 1
		(parser:choice (parser:peek rfc2822-parser:crlf) (parser:end))
		rfc2822-parser:utext))

(define-parser rfc2822-parser:unstructured
	(parser:string:append:repeated-until
		(parser:deep-choice 
			(parser:peek 
				(parser:sequence 
					rfc2822-parser:crlf 
					(parser:choice 
						(parser:end) 
						(parser:char-not-in-set (char-set #\space #\tab)))))
			(parser:end))
		(parser:deep-choice 
			rfc2822-parser:fws
			(parser:string:at-least-until 1
				(parser:choice (parser:peek rfc2822-parser:crlf) (parser:end))
				rfc2822-parser:utext))))

@

\section{Obsolete Tokens (4.1)}

<<Obsolete>>=
(define-parser obs-qp
	(parser:sequence (parser:char= #\\)
		(parser:char-in-set char-set:full)))

(define-parser obs-text 
	(parser:char-in-set char-set:full))

(define-parser obs-utext obs-text)

(define-parser obs-phrase
	(*parser [w rfc2822-parser:word]
					 [rest (parser:string:append:repeated
									 (parser:choice 
										 rfc2822-parser:word
										 (parser:string= ".")
										 rfc2822-parser:cfws))]
		(parser:return (string-append w rest))))
		
(define-parser obs-phrase-list
	(parser:deep-choice
		(*parser [lst (parser:list:at-least 1
										(*parser [p (parser:optional #f 
																	rfc2822-parser:phrase)]
														 [rfc2822-parser:cfws-opt]
														 [(parser:char= #\,)]
														 [rfc2822-parser:cfws-opt]
											(parser:return p)))]
						 [last (parser:optional #f rfc2822-parser:phrase)]
			(parser:return
				(filter (lambda (x) x)
					(append lst (list last)))))
		rfc2822-parser:phrase))

@


\chapter{Date and Time Specification (RFC 3.3)}
This following parsers handle the RFC's definition of date and time, 
and return the date and time object as a date object in Chez Scheme. 
There is little validation occuring in this specification other than 
what is necessary to parser the field. 
As such, it does not do simple checking like assuring that the 
numeric day of the month corresponds to the day of the week given, 
\&c.

<<Imports>>=
(only (scheme) 
	make-date
	date-second date-hour date-minute date-day date-month date-year
	date-zone-offset)
@

<<Exports>>=
rfc2822-parser:date-time
@

<<Field Parsing>>=
(define-parser rfc2822-parser:date-time
	(*parser [(parser:optional #f 
							(parser:sequence 
								rfc2822-parser:day-of-week
								(parser:char= #\,)))]
					 [date rfc2822-parser:date]
					 [rfc2822-parser:fws]
					 [time rfc2822-parser:time]
					 [rfc2822-parser:cfws-opt]
		(parser:return 
			(make-date 0
				(date-second time)
				(date-minute time)
				(date-hour time)
				(date-day date)
				(date-month date)
				(date-year date)
				(date-zone-offset time)))))

(define-parser rfc2822-parser:day-of-week
	(parser:deep-choice
		(parser:sequence %fws-opt rfc2822-parser:day-name)
		obs-day-of-week))

(define-parser rfc2822-parser:day-name
	(parser:deep-choice
		(parser:string-ci= "mon")
		(parser:string-ci= "tue")
		(parser:string-ci= "wed")
		(parser:string-ci= "thu")
		(parser:string-ci= "fri")
		(parser:string-ci= "sat")
		(parser:string-ci= "sun")))
		
(define-parser rfc2822-parser:date
	(*parser [day rfc2822-parser:day]
					 [month rfc2822-parser:month]
					 [year rfc2822-parser:year]
		(parser:return
			(make-date 0 0 0 0 day month year 0))))
			
(define-parser rfc2822-parser:year
	(parser:deep-choice parser-4*digit obs-year))

(define-parser rfc2822-parser:month
	(parser:deep-choice
		(parser:single-bracketed rfc2822-parser:fws 
			(*parser [name rfc2822-parser:month-name]
				(parser:return
					(case (string->symbol name)
						[(jan) 1]
						[(feb) 2]
						[(mar) 3]
						[(apr) 4]
						[(may) 5]
						[(jun) 6]
						[(jul) 7]
						[(aug) 8]
						[(sep) 9]
						[(oct) 10]
						[(nov) 11]
						[(dec) 12]))))
		obs-month))
	 
(define-parser rfc2822-parser:month-name
	(parser:deep-choice
		(parser:string-ci= "jan")
		(parser:string-ci= "feb")
		(parser:string-ci= "mar")
		(parser:string-ci= "apr")
		(parser:string-ci= "may")
		(parser:string-ci= "jun")
		(parser:string-ci= "jul")
		(parser:string-ci= "aug")
		(parser:string-ci= "sep")
		(parser:string-ci= "oct")
		(parser:string-ci= "nov")
		(parser:string-ci= "dec")))

(define-parser rfc2822-parser:day
	(parser:deep-choice
		(parser:sequence %fws-opt parser-1*2digit)
		obs-day))

(define-parser rfc2822-parser:time
	(*parser [time rfc2822-parser:time-of-day]
					 [rfc2822-parser:fws]
					 [zone rfc2822-parser:zone]
		(parser:return
			(make-date 0
				(date-second time)
				(date-minute time)
				(date-hour time)
				1 1 1901
				zone))))
		
(define-parser rfc2822-parser:time-of-day
	(*parser [hour rfc2822-parser:hour]
					 [(parser:char= #\:)]
					 [minute rfc2822-parser:minute]
					 [second (parser:optional 0 
										 (parser:sequence 
											 (parser:char= #\:) 
											 rfc2822-parser:second))]
		(parser:return
			(make-date 0 second minute hour
				1 1 1901 0))))

(define-parser rfc2822-parser:hour
	(parser:deep-choice parser-2digit obs-hour))
(define-parser rfc2822-parser:minute
	(parser:deep-choice parser-2digit obs-minute))
(define-parser rfc2822-parser:second
	(parser:deep-choice parser-2digit obs-second))

(define-parser rfc2822-parser:zone
	(parser:deep-choice 
		(*parser [sign (parser:choice 
										 (parser:sequence  
											 (parser:char= #\+) 
											 (parser:return +))
										 (parser:sequence 
											 (parser:char= #\-) 
											 (parser:return -)))]
						 [offset parser-4digit]
			(parser:return (sign offset)))
		obs-zone))

@

The following are some simple parsers for digits 
that return the digits converted from their strings into numbers.

<<Field Parsing>>=
(define-parser parser-1*2digit (parser:string-number:between 1 2))
(define-parser parser-4*digit (parser:string-number:at-least 4))
(define-parser parser-4digit (parser:string-number:exactly 4))
(define-parser parser-2digit (parser:string-number:exactly 2))

@

\section{Obsolete Time Formats (4.3)}

The following parsers parse formats that are marked as obsolete 
and must not be generated by compliant programs,
but compliant programs must still be able to parse them. 

<<Obsolete>>=
(define-parser obs-day-of-week
	(parser:single-bracketed rfc2822-parser:cfws-opt rfc2822-parser:day-name))

(define-parser obs-year
	(parser:single-bracketed rfc2822-parser:cfws-opt
		(parser:string-number:at-least 2)))

(define-parser obs-month
	(parser:single-bracketed rfc2822-parser:cfws
		rfc2822-parser:month-name))

(define-parser obs-day
	(parser:single-bracketed rfc2822-parser:cfws-opt parser-1*2digit))

(define-parser obs-hour
	(parser:single-bracketed rfc2822-parser:cfws-opt parser-2digit))

(define-parser obs-minute
	(parser:single-bracketed rfc2822-parser:cfws-opt parser-2digit))

(define-parser obs-second
	(parser:single-bracketed rfc2822-parser:cfws-opt parser-2digit))
	
@

Note that when parsing time zones, 
the RFC states that military times should all 
be treated as GMT unless there is out of band information 
to suggest treating them differently. 
While this is strange, 
I do this here to follow with the standard, 
since there is no way at present to determine 
how to treat the military time.

<<Obsolete>>=
(define-parser obs-zone
	(parser:deep-choice
		(zone-parser 0 "UT" "GMT")
		(zone-parser -4 "EDT")
		(zone-parser -5 "EST" "CDT")
		(zone-parser -6 "CST" "MDT")
		(zone-parser -7 "MST" "PDT")
		(zone-parser -8 "PST")
		(parser:sequence 
			(parser:char-in-set char-set:letter)
			(parser:return 0))))

(define (zone-parser offset . values)
	(parser:sequence
		(apply parser:deep-choice
			(map parser:string-ci= values))
		(parser:return offset)))

@

\chapter{Address Specification (RFC 3.4)}

Addresses are either individual mailboxes or groups thereof.

<<Imports>>=
(rnrs records syntactic)
@

<<Exports>>=
rfc2822-parser:address
@

<<Datatypes>>=
(define-record-type rfc2822-address (fields name local domain))
(define-record-type rfc2822-group (fields name addresses))
@

<<Field Parsing>>=
(define-parser rfc2822-parser:address
	(parser:deep-choice rfc2822-parser:mailbox rfc2822-parser:group))

@

Mailboxes are either regular address specifications or named 
specifications.

<<Field Parsing>>=
(define-parser rfc2822-parser:mailbox
	(parser:deep-choice rfc2822-parser:name-addr rfc2822-parser:addr-spec))

@

Named addresses are angled addresses prepended by an optional display name.

<<Field Parsing>>=
(define-parser rfc2822-parser:name-addr
	(*parser [name (parser:optional #f rfc2822-parser:display-name)]
					 [addr rfc2822-parser:angle-addr]
		(parser:return
			(make-rfc2822-address name
				(rfc2822-address-local addr)
				(rfc2822-address-domain addr)))))

@

An angle address is just an angle delimited address specification.

<<Field Parsing>>=
(define-parser rfc2822-parser:angle-addr
	(parser:deep-choice
		(parser:bracketed
			(parser:sequence rfc2822-parser:cfws-opt (parser:char= #\<))
			(parser:sequence (parser:char= #\>) rfc2822-parser:cfws-opt)
			rfc2822-parser:addr-spec)
		obs-angle-addr))

@

Groups are named lists of addresses. They may have no addresses 
at all.

<<Field Parsing>>=
(define-parser rfc2822-parser:group
	(*parser [name rfc2822-parser:display-name]
					 [(parser:char= #\:)]
					 [mailbox-list
						(parser:optional #f
							(parser:deep-choice 
								rfc2822-parser:mailbox-list
								rfc2822-parser:cfws))]
					 [(parser:char= #\;)]
					 [rfc2822-parser:cfws-opt]
		(parser:return
			(make-rfc2822-group name mailbox-list))))

@

Display names are phrases.

<<Field Parsing>>=
(define-parser rfc2822-parser:display-name rfc2822-parser:phrase)

@

Mailbox lists and address lists are comma separated mailboxes.

<<Field Parsing>>=
(define-parser rfc2822-parser:mailbox-list
	(parser:deep-choice
		(*parser [first rfc2822-parser:mailbox]
						 [rest (parser:list:repeated
										 (parser:sequence 
											 (parser:char= #\,) 
											 rfc2822-parser:mailbox))]
			(parser:return (cons first rest)))
		obs-mbox-list))

(define-parser rfc2822-parser:address-list
	(parser:deep-choice
		(*parser [first rfc2822-parser:address]
						 [rest (parser:list:repeated
										 (parser:sequence 
											 (parser:char= #\,) 
											 rfc2822-parser:address))]
			(parser:return (cons first rest)))
		obs-addr-list))

@

An address specification consistes of a local and a domain part.

<<Field Parsing>>=
(define-parser rfc2822-parser:addr-spec
	(*parser [local rfc2822-parser:local-part]
					 [(parser:char= #\@)]
					 [domain rfc2822-parser:domain]
		 (parser:return
			 (make-rfc2822-address #f local domain))))

@

Local parts are either atoms with dots or quoted strings.

<<Field Parsing>>=
(define-parser rfc2822-parser:local-part
	(parser:deep-choice 
		rfc2822-parser:quoted-string 
		rfc2822-parser:dot-atom
		obs-local-part))

@

Domains use the possible domain literal.

<<Field Parsing>>=
(define-parser rfc2822-parser:domain
	(parser:deep-choice
		rfc2822-parser:dot-atom
		rfc2822-parser:domain-literal
		obs-domain))

@

A domain literal specifies an actual, specific host.

<<Datatypes>>=
(define-record-type rfc2822-domain-literal (fields value))
@

<<Field Parsing>>=
(define-parser rfc2822-parser:domain-literal
	(*parser 
		[res 
		 (parser:bracketed
			 (parser:sequence rfc2822-parser:cfws-opt (parser:char= #\[))
			 (parser:sequence (parser:char= #\]) rfc2822-parser:cfws-opt)
			 (parser:string:append:repeated
				 (parser:single-bracketed %fws-opt rfc2822-parser:dcontent)))]
		(parser:return (make-rfc2822-domain-literal res))))

@

We handle quotes in dcontent.

<<Field Parsing>>=
(define-parser rfc2822-parser:dcontent
	(parser:string:at-least 1
		(parser:choice rfc2822-parser:dtext rfc2822-parser:quoted-pair)))

(define-parser rfc2822-parser:dtext
	(parser:char-in-set
		(char-set-difference char-set:full
			char-set:whitespace
			(char-set #\[ #\] #\\))))

@

\section{Obsolete Address Parsers}

This section details the obsolete parsers that 
parse the obsolete syntax as required by RFC 2822.

Firstly, we make an obslete address structure that 
is a child of the regular address structure. 
It adds a route, which only exists in the old style. 

<<Datatypes>>=
(define-record-type rfc2822-obsolete-address
	(parent rfc2822-address)
	(fields route))
@

<<Obsolete>>=
(define-parser obs-angle-addr
	(parser:bracketed
		(parser:sequence rfc2822-parser:cfws-opt (parser:char= #\<))
		(parser:sequence (parser:char= #\>) rfc2822-parser:cfws-opt)
		(*parser [route (parser:optional #f obs-route)]
						 [addr rfc2822-parser:addr-spec]
			(parser:return
				(if route
						(make-rfc2822-obsolete-address
							#f
							(rfc2822-address-local addr)
							(rfc2822-address-domain addr)
							route)
						addr)))))

(define-parser obs-route
	(parser:bracketed
		rfc2822-parser:cfws-opt
		(parser:sequence (parser:char= #\:) rfc2822-parser:cfws-opt)
		obs-domain-list))

(define-parser obs-domain-list
	(parser:list:at-least 1
		(parser:sequence
			(parser:repeated (lambda (x y) x) (parser:epsilon)
				(parser:choice (parser:char= #\,) rfc2822-parser:cfws))
			(parser:char= #\@)
			rfc2822-parser:domain)))

(define-parser obs-mbox-list
	(*parser [lst (parser:list:at-least 1
									(*parser [box (parser:optional #f 
																	rfc2822-parser:mailbox)]
													 [rfc2822-parser:cfws-opt]
													 [(parser:char= #\,)]
													 [rfc2822-parser:cfws-opt]
										(parser:return box)))]
					 [last (parser:optional #f rfc2822-parser:mailbox)]
		(parser:return 
			(filter (lambda (x) x) 
				(append lst (list last))))))

(define-parser obs-addr-list
	(*parser [lst (parser:list:at-least 1
									(*parser [box (parser:optional #f 
																	rfc2822-parser:address)]
													 [rfc2822-parser:cfws-opt]
													 [(parser:char= #\,)]
													 [rfc2822-parser:cfws-opt]
										(parser:return box)))]
					 [last (parser:optional #f rfc2822-parser:address)]
		(parser:return 
			(filter (lambda (x) x) 
				(append lst (list last))))))

(define-parser obs-local-part
	(*parser [first rfc2822-parser:word]
					 [rest (parser:string:append:repeated
									 (*parser [(parser:char= #\.)]
														[v rfc2822-parser:word]
										 (parser:return (string-append "." v))))]
		(parser:return (string-append first rest))))

(define-parser obs-domain
	(*parser [first rfc2822-parser:atom]
					 [rest (parser:string:append:repeated
									 (*parser [(parser:char= #\.)]
														[v rfc2822-parser:atom]
										 (parser:return (string-append "." v))))]
		(parser:return (string-append first rest))))

@

\chapter{Message Parsers (3.5)}

<<Exports>>=
rfc2822-parser:message
rfc2822-parser:body
@

<<Imports>>=
(only (scheme) format)
@

<<Datatypes>>=
(define-record-type rfc2822-message (fields fields body))
@

<<Message Parsing>>=
(define-parser rfc2822-parser:message
	(*parser [fields (parser:deep-choice 
										 rfc2822-parser:fields
										 obs-fields)]
					 [body (parser:optional #f rfc2822-parser:body)]
		(parser:return
			(make-rfc2822-message fields body))))

(define-parser rfc2822-parser:body
	(*parser 
			[lines 
				(parser:list:repeated
					(parser:sequence rfc2822-parser:crlf
						(parser:string:repeated rfc2822-parser:text)))]
		(parser:return (format "狺捃蜍铪扉铄螬┅茔栳痿弪崎屐腻骈铋糸镱ǔ订技砒痫螋缶窘蜴悴覆箔疳蝮弪烘殄熹蜴悴覆箔疳蝮弪烘殄熹嗅蝮轭翳骈屐潴滹弩铒弪蝻汨邈腴铉镦翳矧溴矧豉疱镦骈屐潴翳狒屮轶舢轴扉溽糸铉麒弭桢玳鲥骈屐扉篝轶鲠扉移哺膊礤篌徵桢徜弪轶戾骠麸犷雉桢痱镢邃躜瀹徐遽箦铒翦翳狒麇犰箫溴鲩狒骝镯翳移轭翳狒麇滹瞌溟篝轭珲轶忮赭邋翳镡箫戾翦骈屐篝戾桢蝈深篝遽麇蝈徜轭翳孱糸蝈箦镦骈屐潴鏖翳秕汨邈腴铉麒弭桢翳趄徙骈屐潴泔礤骈蝮舢娱钽翳轶轶牾篝疳蝮轭绗麇汜滹翳轶技崎屐嗅蝮轭缇窘ㄤ彐轭瀛疳蝮弪蜴悴覆箔疳蝮弪烘殄熹疳蝮弪红轶艉蝈疱狒邃蜴悴覆箔疳蝮弪烘殄熹┅ㄤ彐轭瀛疳蝮弪蜴悴覆箔疳蝮弪烘殄熹疳蝮弪轰邋瓠汨镩沐蜴悴覆箔疳蝮弪候弭躜蜴悴覆箔疳蝮弪候邈彘鲥蜴悴覆箔疳蝮弪候弩孱舡溽翦蜴悴覆箔疳蝮弪候弩孱舡骝镯蜴悴覆箔疳蝮弪候弩孱舡箦钿弪蜴悴覆箔疳蝮弪候弩孱舡麸蜴悴覆箔疳蝮弪候弩孱舡沣蜴悴覆箔疳蝮弪候弩孱舡忏蜴悴覆箔疳蝮弪候弩孱舡眢绛殇蜴悴覆箔疳蝮弪猴蜷绛溽翦蜴悴覆箔疳蝮弪烘蝻蜴悴覆箔疳蝮弪后孱溴蜴悴覆箔疳蝮弪候屦禊麸蜴悴覆箔疳蝮弪呼蜴悴覆箔疳蝮弪恒蜴悴覆箔疳蝮弪衡沣蜴悴覆箔疳蝮弪喉弩筢珏殇蜴悴覆箔疳蝮弪洪瞽蝈痨麸蜴悴覆箔疳蝮弪候彐弪孱沐蜴悴覆箔疳蝮弪后踱赍泗蜴悴覆箔疳蝮弪恒镯礤铘蜴悴覆箔疳蝮弪弘妁黠蜾蜴悴覆箔疳蝮弪猴痿轱钺飙骈屐洎荏邈糸镱轴扉溽糸铉湾篌徵弩轴扉溽糸铉礤篌徵弩蝈聃轵弩翳狒麇犰箫鲠扉溽翦翳骈屐泔躅趔澡弩狎麸泔眇扉汜翦麸滹漉蜷铉铒蝽犰疳蝮轭鏖翳秕泔铈躞轭翳泔溴族磲犰箫鏖箬麸殓铒蝈翳轶鲠扉溽糸镱骘箫礤蝈狍镱义玑蜾戾篌麇痱秭殇圹鲠扉溽翦蜴悴覆箔骈屐洵泔躅趔葺麸蜥轶犷狍箦螋轱鲩镬狒轱弪蝻殒翳礤篌徵轶铒鲠扉洚技身痫螋缶窘蝾蝮孱蹴螬蜷狍趄徜骘镦祜镳蝾蝮泔铘蝻飑技湾篌徵嗅蝮轭缇窘ㄤ彐轭鲠扉溽翦蜴悴覆箔骈屐洵泔躅趔骈屐潴ㄤ彐轭骈屐洵钺礤Ж矧殓溽翦骝镯箦钿弪蝈痨麸麸沣忏礤篌徵瀛殇轭蝈痨麸蝈驽蝈钽弩篚怅邈泔眄孱趔脲黠蜾镳糸镱犰骈屐洎ㄤ彐轭骈屐洵轭溴ㄥ铛憝箦舡轭溴弪磲脲孱蹴弪狒轱骈屐洵钺礤螬┅ㄤ彐轭骈屐洵泔躅趔磲脲鲥泗矧戾铉翳骈屐洵钺礤螬癌ㄤ彐轭ㄦ殄熹泔躅骈屐洎鲥泗矧蝈骈屐洵泔躅趔ㄦ殄熹轭溴骈屐洎┅ㄤ彐轭ㄦ殄熹轭恪骈屐洎麒孱礤眈骈屐骈屐洵钺礤螬戾ㄛㄦ殄熹轭溴骈屐洎荸鲥泗矧箦簟骈屐洵泔躅趔ǐㄦ殄熹泔躅骈屐洎┅┅ㄤ彐轭眭祠轲戾骝镯ｆㄤ彐轭铒瞽趄徙瀛骈屐潴祜镳ㄛ骘骈屐蝈篝ㄩ瞽扉篝骈屐潴┹埙栝戾ㄥ窨趄徙ㄣ狎骈屐洎┹骄ㄣ潋蝈篝┅祜镳ㄛ骘骈屐ㄩ瞽扉篝铒瞽趄徙瀛骈屐潴┹ㄣ狍ㄣ狎骈屐洎郇骝镯麒孱铛祆ㄣ潋骈屐洎箦簟眭祠轲戾骝镯ｔ┅郇趄徙濠ㄡ篌弪糸镱鲩镬狒轱鲠扉溽翦蜴悴覆箔骈屐洵泔躅趔⒃蜥沐骈屐镢沲蝮徭翦蝈珲灬骈屐潴┹坼祗ㄦ殄熹轭恪ㄣ狎骈屐洎┹ㄦ殄熹轭恪ㄣ狎骈屐洎┅ㄡ篌弪ㄦ殄熹泔躅э蜷绛溽翦┅ㄡ篌弪ㄦ殄熹泔躅ф蝻愆┅ㄡ篌弪ㄩ眭祠轲戾骝镯ㄦ殄熹泔躅箦钿弪┅冀ㄦ殄熹泔躅箦钿弪暴┅ㄡ篌弪ㄦ矧犰灬礅溽冀ㄦ殄熹泔躅暴Ж蝈痨麸麸沣忏礤篌徵瀛殇轭蝈痨麸蝈驽蝈钽弩篚怅邈舂┅荏邈糸镱镶箫戾翦湾篌徵崎屐潴ù旦阻孱疳蝮轭骈屐潴轭翳镡箫戾翦篝戾翳弪轶铒蝈聃轵屙孱麸忪镢趄徙弩麸珏翳弪鏖翳雉桢泔溴澡轶戾狯弩祜镦躅箴邈殒殄忮栳鲩矧涉翳礤篌徵骈屐潴泔礤骝镯犷镡箫戾翦篝戾翳孱麇牾篝徜箴邈獒骈屐圹丨镶箫戾翦儒徜弪筝麸戾翳屙腩秣翳狒翳妁栳鲥麸滹翳轭珞翳栳蜾弪麽荛刎睾澡弪秕玷麸忮忮趑弪麽麸滹翳轶技镶箫戾翦揪ㄤ彐轭瀛疳蝮弪镡蟓骈屐潴疳蝮弪红轶艉蝈疱狒邃疳蝮弪轰邋瓠汨镩沐镡蟓蝈趱蝾镡蟓蝈沐轹邃镡蟓矧殓溽翦镡蟓骝镯镡蟓箦钿弪镡蟓蝈痨麸镡蟓麸镡蟓沣镡蟓忏镡蟓礤篌徵瀛殇镡蟓轭蝈痨麸镡蟓蝈驽蝈钽弩镡蟓篚怅邈镡蟓泔眄孱趔镡蟓脲黠蜾镡蟓蝈箦铘溽翦镡蟓蝈箦铘骝镯镡蟓蝈箦铘箦钿镡蟓蝈箦铘蝈痨镡蟓蝈箦铘麸镡蟓蝈箦铘沣镡蟓蝈箦铘忏镡蟓蝈箦铘黹镡蟓镳糸镱犰┅荏邈糸镱崎屐嗅蝮弪蔑铞孱殄钽弩澡铄箦泗轱铙溴犰鏖翳翳徙趱犰骈屐溴骈铋糸镱螽澡骘祆秣轭轶泔铞孱殄钽疳蝮弪骘骈屐潴技砒痫螋缶窘疳蝮弪候驺哺膊桢徜弪技蒸殪轸殄缶窘ㄤ彐轭疳蝮弪候驺哺膊桢徜弪钺礤桢徜篝疳蝮弪í疳蝮弪郇疳蝮弪后趄轭绛汩桢徜篝颟郇疳蝮弪恒栳蚪＼憨垓弩疳蝮弪垓驺哺膊疳蝮弪恒蜢孑疳蝮弪候弭躜ㄣ镱钺礤蝈螬┅ㄤ彐轭疳蝮弪猴怏桢徜弪钺礤骈屐疳蝮弪í疳蝮弪郇疳蝮弪后趄轭绛汩骈屐洎郇疳蝮弪后趄轭绾蝈疱狒邃蜴悴覆箔疳蝮弪瑚箴┹郇疳蝮弪恒栳蚪＼憨垓弩疳蝮弪垓驺哺膊疳蝮弪恒蜢孑疳蝮弪候弭躜ㄣ镱钺礤蝈螬┅荏邈糸镱向殓轭狒轱溽翦骈屐ǔ懂暴技崎屐嗅蝮轭缇窘ㄤ彐轭瀛疳蝮弪蜴悴覆箔疳蝮弪猴蜷绛溽翦疳蝮弪候驺哺膊桢徜弪э蜷绛溽翦⒛狒澧蜴悴覆箔疳蝮弪轰狒瀛糸礤┅荏踱箦泗轱铥镶箫戾翦向殓轭狒轱尼翦崎屐ù诞暴技镶箫戾翦揪ㄤ彐轭瀛疳蝮弪镡蟓矧殓溽翦疳蝮弪猴怏桢徜弪э蜷绛溽翦⒛狒澧蜴悴覆箔疳蝮弪轰狒瀛糸礤┅荏邈糸镱向殓轭狒矧崎屐潴ǔ懂博技崎屐嗅蝮轭缇窘ㄤ彐轭瀛疳蝮弪蜴悴覆箔疳蝮弪烘蝻疳蝮弪候驺哺膊桢徜弪ф蝻⑵蝻恝蜴悴覆箔疳蝮弪喉衢焘秫扉篝┅ㄤ彐轭瀛疳蝮弪蜴悴覆箔疳蝮弪后孱溴疳蝮弪候驺哺膊桢徜弪箦钿弪⒂孱溴颌蜴悴覆箔疳蝮弪喉衢焘秫┅ㄤ彐轭瀛疳蝮弪蜴悴覆箔疳蝮弪候屦禊麸疳蝮弪候驺哺膊桢徜弪蝈痨麸⒁屦禊燥蜴悴覆箔疳蝮弪横滗蝈篌扉篝┅荏踱箦泗轱铥镶箫戾翦向殓轭狒矧崎屐潴ù诞博技镶箫戾翦揪ㄤ彐轭瀛疳蝮弪镡蟓骝镯疳蝮弪猴怏桢徜弪ф蝻⑵蝻恝蜴悴覆箔疳蝮弪喉衢焘秫扉篝┅ㄤ彐轭瀛疳蝮弪镡蟓箦钿弪疳蝮弪猴怏桢徜弪箦钿弪⒂孱溴颌蜴悴覆箔疳蝮弪喉衢焘秫┅ㄤ彐轭瀛疳蝮弪镡蟓蝈痨麸疳蝮弪猴怏桢徜弪蝈痨麸⒁屦禊燥蜴悴覆箔疳蝮弪喉衢焘秫扉篝┅荏邈糸镱腻篝轭狒轱龄潋弩崎屐潴ǔ懂畅技崎屐嗅蝮轭缇窘ㄤ彐轭瀛疳蝮弪蜴悴覆箔疳蝮弪呼疳蝮弪候驺哺膊桢徜弪麸⒃铫蜴悴覆箔疳蝮弪横滗蝈篌扉篝┅ㄤ彐轭瀛疳蝮弪蜴悴覆箔疳蝮弪恒疳蝮弪候驺哺膊桢徜弪с⒚恽蜴悴覆箔疳蝮弪横滗蝈篌扉篝┅ㄤ彐轭瀛疳蝮弪蜴悴覆箔疳蝮弪衡沣疳蝮弪候驺哺膊桢徜弪р沣⒙沣疳蝮弪轰邋瓠汨镩沐蜴悴覆箔疳蝮弪横滗蝈篌扉篝蜴悴覆箔疳蝮弪恒骥蟓镳舂┅荏踱箦泗轱铥镶箫戾翦腻篝轭狒轱龄潋弩崎屐潴ù诞博技镶箫戾翦揪ㄤ彐轭瀛疳蝮弪镡蟓麸疳蝮弪猴怏桢徜弪麸⒃铫蜴悴覆箔疳蝮弪横滗蝈篌扉篝┅ㄤ彐轭瀛疳蝮弪镡蟓沣疳蝮弪猴怏桢徜弪с⒚恽蜴悴覆箔疳蝮弪横滗蝈篌扉篝┅ㄤ彐轭瀛疳蝮弪镡蟓忏疳蝮弪猴怏桢徜弪р沣⒙沣疳蝮弪轰邋瓠汨镩沐蜴悴覆箔疳蝮弪横滗蝈篌扉篝蜴悴覆箔疳蝮弪恒骥蟓镳舂┅荏邈糸镱射孱糸骈汜糸镱崎屐潴ǔ懂穿技砒痫螋缶窘蜴悴覆箔疳蝮弪喉箸殇技崎屐嗅蝮轭缇窘ㄤ彐轭瀛疳蝮弪蜴悴覆箔疳蝮弪喉弩筢珏殇疳蝮弪候驺哺膊桢徜弪ы弩筢珏殇⑼弩筢珏赡蜴悴覆箔疳蝮弪喉箸殇┅ㄤ彐轭瀛疳蝮弪蜴悴覆箔疳蝮弪洪瞽蝈痨麸疳蝮弪候驺哺膊桢徜弪ч瞽蝈痨麸⑸瞽义痨燥疳蝮弪红轶艉狒戾狍蜴悴覆箔疳蝮弪喉箸殇┅ㄤ彐轭瀛疳蝮弪蜴悴覆箔疳蝮弪候彐弪孱沐疳蝮弪候驺哺膊桢徜弪蝈驽蝈钽弩⒁彐弪孱沐螈疳蝮弪红轶艉狒戾狍蜴悴覆箔疳蝮弪喉箸殇┅ㄤ彐轭瀛疳蝮弪蜴悴覆箔疳蝮弪喉箸殇疳蝮弪衡蜥汶弭邃疳蝮弪后羼蹂钽蜴悴覆箔疳蝮弪恒骥蟓镳疳蝮弪恒栳蚪＼缉疳蝮弪后羼蹂钽疳蝮弪恒栳蚪＼京蜴悴覆箔疳蝮弪恒骥蟓镳舂í疳蝮弪垤彐殇戾骠郇疳蝮弪恒栳蚪＼扩垓殓梏殇蜷玷糨疳蝮弪候弭躜篝蜷铉狃疱钿戾骠⒗蜷玷舂┅┅ㄤ彐轭瀛疳蝮弪殇戾骠疳蝮弪轰邋瓠汨镩沐蜴悴覆箔疳蝮弪轰雉狒镯翦蜴悴覆箔疳蝮弪侯锃骘熹聃雉镡蟓殇戾骠┅ㄤ彐轭瀛疳蝮弪殇蜷玷疳蝮弪轰邋瓠汨镩沐蜴悴覆箔疳蝮弪轰雉狒镯翦蜴悴覆箔疳蝮弪侯锃骘熹扉翦蜥镡蟓殇蜷玷舂ㄤ彐轭瀛疳蝮弪蜴悴覆箔疳蝮弪侯锃骘熹聃雉疳蝮弪后轭珈瀛怛徙脲翦疳蝮弪恒栳蚪＼疳蝮弪后趄轭绾蝈疱狒邃疳蝮弪恒栾殂蜴悴覆箔疳蝮弪厚翦蜴悴覆箔疳蝮弪厚躏翦洵疳轵┅┅ㄤ彐轭瀛疳蝮弪蜴悴覆箔疳蝮弪侯锃骘熹扉翦蜥疳蝮弪衡蜥汶弭邃疳蝮弪恒栳蚪＼郓疳蝮弪恒栳蚪＼荸疳蝮弪后趄轭绾蝈疱狒邃蜴悴覆箔疳蝮弪轰翦蜴悴覆箔疳蝮弪厚躏翦洵疳轵┅荏踱箦泗轱铥镶箫戾翦射孱糸骈汜糸镱崎屐ù诞穿技镶箫戾翦揪ㄤ彐轭瀛疳蝮弪镡蟓礤篌徵瀛殇疳蝮弪猴怏桢徜弪ы弩筢珏殇⑼弩筢珏赡蜴悴覆箔疳蝮弪喉箸殇┅ㄤ彐轭瀛疳蝮弪镡蟓轭蝈痨麸疳蝮弪猴怏桢徜弪ч瞽蝈痨麸⑸瞽义痨燥疳蝮弪红轶艉蝈疱狒邃疳蝮弪轰邋瓠汨镩沐蜴悴覆箔疳蝮弪吼栩狍蜴悴覆箔疳蝮弪喉箸殇┅┅ㄤ彐轭瀛疳蝮弪镡蟓蝈驽蝈钽弩疳蝮弪猴怏桢徜弪蝈驽蝈钽弩⒁彐弪孱沐螈疳蝮弪红轶艉蝈疱狒邃疳蝮弪轰邋瓠汨镩沐蜴悴覆箔疳蝮弪吼栩狍蜴悴覆箔疳蝮弪喉箸殇┅┅ㄤ彐轭瀛疳蝮弪镡蟓殇戾骠蜴悴覆箔疳蝮弪红镢犰疳螋ㄤ彐轭瀛疳蝮弪镡蟓殇蜷玷蜴悴覆箔疳蝮弪轰镯衢瞟荏邈糸镱深骘蝽狒轱崎屐潴ǔ懂旦技崎屐嗅蝮轭缇窘ㄤ彐轭瀛疳蝮弪蜴悴覆箔疳蝮弪后踱赍泗疳蝮弪候驺哺膊桢徜弪篚怅邈⒂踱赍泗蜴悴覆箔疳蝮弪乎铙趄蹉趱蝈洎ㄤ彐轭瀛疳蝮弪蜴悴覆箔疳蝮弪恒镯礤铘疳蝮弪候驺哺膊桢徜弪с镯礤铘⒚镯礤铘螈蜴悴覆箔疳蝮弪乎铙趄蹉趱蝈洎ㄤ彐轭瀛疳蝮弪蜴悴覆箔疳蝮弪弘妁黠蜾疳蝮弪候驺哺膊桢徜弪щ妁黠蜾⑺妁黠蜾螈í疳蝮弪坻轵篝蜴悴覆箔疳蝮弪吼栩狍遢垓弩疳蝮弪红轶艉蝈疱狒邃疳蝮弪后羼蹂钽疳蝮弪恒栳蚪＼蜴悴覆箔疳蝮弪吼栩狍濠┹疳蝮弪候弭躜ㄣ镱骈蝮蝈篝┅┅荏踱箦泗轱铥镶箫戾翦深骘蝽狒轱崎屐潴ù诞旦技镶箫戾翦揪ㄤ彐轭瀛疳蝮弪镡蟓篚怅邈疳蝮弪猴怏桢徜弪篚怅邈⒂踱赍泗蜴悴覆箔疳蝮弪乎铙趄蹉趱蝈洎ㄤ彐轭瀛疳蝮弪镡蟓泔眄孱趔疳蝮弪猴怏桢徜弪с镯礤铘⒚镯礤铘螈蜴悴覆箔疳蝮弪乎铙趄蹉趱蝈洎ㄤ彐轭瀛疳蝮弪镡蟓脲黠蜾疳蝮弪猴怏桢徜弪щ妁黠蜾⑺妁黠蜾螈镡蟓痂蜥箦扉篝┅荏邈糸镱义箦铘崎屐潴ǔ懂订技崎屐嗅蝮轭缇窘ㄤ彐轭瀛疳蝮弪蜴悴覆箔疳蝮弪候弩孱舡溽翦疳蝮弪候驺哺膊桢徜弪蝈箦铘溽翦⒁弩孱舡尼翦蜴悴覆箔疳蝮弪轰狒瀛糸礤┅ㄤ彐轭瀛疳蝮弪蜴悴覆箔疳蝮弪候弩孱舡骝镯疳蝮弪候驺哺膊桢徜弪蝈箦铘骝镯⒁弩孱舡乞镯蜴悴覆箔疳蝮弪喉衢焘秫扉篝┅ㄤ彐轭瀛疳蝮弪蜴悴覆箔疳蝮弪候弩孱舡箦钿弪疳蝮弪候驺哺膊桢徜弪蝈箦铘箦钿弪⒁弩孱舡渝钿弪蜴悴覆箔疳蝮弪喉衢焘秫┅ㄤ彐轭瀛疳蝮弪蜴悴覆箔疳蝮弪候弩孱舡麸疳蝮弪候驺哺膊桢徜弪蝈箦铘麸⒁弩孱舡燥蜴悴覆箔疳蝮弪横滗蝈篌扉篝┅ㄤ彐轭瀛疳蝮弪蜴悴覆箔疳蝮弪候弩孱舡沣疳蝮弪候驺哺膊桢徜弪蝈箦铘沣⒁弩孱舡勉蜴悴覆箔疳蝮弪横滗蝈篌扉篝┅ㄤ彐轭瀛疳蝮弪蜴悴覆箔疳蝮弪候弩孱舡忏疳蝮弪候驺哺膊桢徜弪蝈箦铘忏⒁弩孱舡裸恽疳蝮弪轰邋瓠汨镩沐蜴悴覆箔疳蝮弪横滗蝈篌扉篝蜴悴覆箔疳蝮弪恒骥蟓镳舂┅ㄤ彐轭瀛疳蝮弪蜴悴覆箔疳蝮弪候弩孱舡眢绛殇疳蝮弪候驺哺膊桢徜弪蝈箦铘眢绛殇⒁弩孱舡腕绛赡蜴悴覆箔疳蝮弪喉箸殇┅荏踱箦泗轱铥镶箫戾翦义箦铘崎屐潴ù诞订技镶箫戾翦揪ㄤ彐轭瀛疳蝮弪镡蟓蝈箦铘溽翦疳蝮弪猴怏桢徜弪蝈箦铘溽翦⒁弩孱舡尼翦蜴悴覆箔疳蝮弪轰狒瀛糸礤┅ㄤ彐轭瀛疳蝮弪镡蟓蝈箦铘骝镯疳蝮弪猴怏桢徜弪蝈箦铘骝镯⒁弩孱舡乞镯蜴悴覆箔疳蝮弪喉衢焘秫扉篝┅ㄤ彐轭瀛疳蝮弪镡蟓蝈箦铘箦钿疳蝮弪猴怏桢徜弪蝈箦铘箦钿弪⒁弩孱舡渝钿弪蜴悴覆箔疳蝮弪喉衢焘秫┅ㄤ彐轭瀛疳蝮弪镡蟓蝈箦铘麸疳蝮弪猴怏桢徜弪蝈箦铘麸⒁弩孱舡燥蜴悴覆箔疳蝮弪横滗蝈篌扉篝┅ㄤ彐轭瀛疳蝮弪镡蟓蝈箦铘沣疳蝮弪猴怏桢徜弪蝈箦铘沣⒁弩孱舡勉蜴悴覆箔疳蝮弪横滗蝈篌扉篝┅ㄤ彐轭瀛疳蝮弪镡蟓蝈箦铘忏疳蝮弪猴怏桢徜弪蝈箦铘忏⒁弩孱舡裸恽疳蝮弪轰邋瓠汨镩沐蜴悴覆箔疳蝮弪横滗蝈篌扉篝蜴悴覆箔疳蝮弪恒骥蟓镳舂┅ㄤ彐轭瀛疳蝮弪镡蟓蝈箦铘黹疳蝮弪猴怏桢徜弪蝈箦铘眢绛殇⒁弩孱舡腕绛赡蜴悴覆箔疳蝮弪喉箸殇┅ㄤ彐轭瀛疳蝮弪镡蟓蝈箦铘蝈痨疳蝮弪猴怏桢徜弪蝈箦铘蝈痨麸⒁弩孱舡义痨燥蜴悴覆箔疳蝮弪横滗蝈篌扉篝┅荏邈糸镱则徙崎屐潴ǔ懂珐物翦翳狒麇篝蜥骝镯翳移箪殓梏禊桢蝈麸箝眇扉纟翳疳蝮轭绠族牾篝痱秭殇翳骈屐疳蝮弪蟋蜥翳弪翳犷珏铄蜥疳蝮弪骘趄徙骈屐潴翳狒黠蹯痱弩蹴徕禊蝈趱蝾箫礤箫螋镦篝蝓泗躜蝈灬翦麸轸技崎屐嗅蝮轭缇窘ㄤ彐轭瀛疳蝮弪蜴悴覆箔疳蝮弪候弭躜疳蝮弪候驺哺膊桢徜弪蝈趱蝾疳翳⒁弭躜瞽嗅翳蜴悴覆箔疳蝮弪吼狒瑭ㄤ彐轭瀛疳蝮弪蜴悴覆箔疳蝮弪吼狒疳蝮弪轰邋瓠汨镩沐疳蝮弪衡蜥汶弭邃疳蝮弪后羼蹂钽蜴悴覆箔疳蝮弪恒骥蟓镳疳蝮弪恒栳蚪＼缉疳蝮弪后羼蹂钽疳蝮弪恒栳蚪＼京蜴悴覆箔疳蝮弪恒骥蟓镳舂疳蝮弪轰邋瓠汨镩沐蜴悴覆箔疳蝮弪横滗颦箴邈蜴悴覆箔疳蝮弪恒骥蟓镳舂镡蟓疳翳┅燥栳钿戾疳蝮轭翳蝈沐轹邃骈屐洮麇痱秭殇犷徜溟糸镱犰篝蝓泗躜瀹技尼翎豉疱缶窘ㄤ彐轭瀛蝈泔蜾豉疱蜴悴覆箔蝈沐轹邃ㄦ殄熹孱趄殄溽翦┅技崎屐嗅蝮轭缇窘ㄤ彐轭瀛疳蝮弪蜴悴覆箔疳蝮弪候邈彘鲥疳蝮弪候驺哺膊桢徜弪蝈沐轹邃⒁邈彘鲥洧í疳蝮弪坼铘蜷弩蜴悴覆箔疳蝮弪侯犴瀛鲠飙扉篝垓驺哺膊疳蝮弪恒骥蟓镳糨郇疳蝮弪恒栳蚪＼哗垆狒蜴悴覆箔疳蝮弪轰狒瀛糸礤疳蝮弪候弭躜磲脲蜴悴覆箔蝈沐轹邃孱趄殄溽翦┅┅ㄤ彐轭瀛疳蝮弪蜴悴覆箔疳蝮弪侯犴瀛鲠飙扉篝疳蝮弪红轶艉蝈疱狒邃疳蝮弪后羼蹂钽蜴悴覆箔疳蝮弪恒骥蟓镳蜴悴覆箔疳蝮弪侯犴瀛鲠飙疳轵┅ㄤ彐轭瀛疳蝮弪蜴悴覆箔疳蝮弪侯犴瀛鲠飙疳轵í疳蝮弪垲犴蜴悴覆箔疳蝮弪洪翦憝钺礤垓驺哺膊疳蝮弪恒骥筝埚犰蹂蜴悴覆箔疳蝮弪洪翦憝鲠祯遢疳蝮弪候弭躜ㄣ镱钺礤鲠祯濠┅ㄤ彐轭瀛疳蝮弪蜴悴覆箔疳蝮弪洪翦憝钺礤í疳蝮弪坻轵篝汨狎蜴悴覆箔疳蝮弪横祓栳垓弩疳蝮弪后趄轭绾蝈疱狒邃疳蝮弪恒栾殂疳蝮弪恒栳蚪＼蜴悴覆箔疳蝮弪横祓栳蜴悴覆箔疳蝮弪轰殓轸┅疳蝮弪候弭躜篝蜷铉狃疱钿篝蜷铉骈蝮舡汨狎蝈篝┅┅ㄤ彐轭瀛疳蝮弪蜴悴覆箔疳蝮弪洪翦憝鲠祯疳蝮弪轰邋瓠汨镩沐疳蝮弪红轶艉狒戾狍蜴悴覆箔疳蝮弪横铉戾徜潋蜴悴覆箔疳蝮弪横滗颦箴邈蜴悴覆箔疳蝮弪喉箸殇蜴悴覆箔疳蝮弪轰镯衢蜴悴覆箔疳蝮弪横麸愆荏踱箦泗轱铥镶箫戾翦则徙崎屐潴ù诞珐技镶箫戾翦揪ㄤ彐轭瀛疳蝮弪镡蟓蝈趱蝾疳蝮弪猴怏桢徜弪蝈趱蝾疳翳⒁弭躜瞽嗅翳蜴悴覆箔疳蝮弪吼狒瑭ㄤ彐轭瀛疳蝮弪镡蟓蝈沐轹邃疳蝮弪猴怏桢徜弪蝈沐轹邃⒁邈彘鲥洧蜴悴覆箔疳蝮弪侯犴瀛鲠飙扉篝┅ㄤ彐轭瀛疳蝮弪镡蟓疳翳镡蟓犷珈瀛徜潋荏邈糸镱橡糸镱犰崎屐潴ǔ懂俯技身痫螋缶窘蝾蝮躅殂镤濠技崎屐嗅蝮轭缇窘ㄤ彐轭瀛疳蝮弪蜴悴覆箔疳蝮弪猴痿轱钺飙骈屐í疳蝮弪坻殄熹钺礤蜴悴覆箔疳蝮弪烘殄熹钺礤郇疳蝮弪恒栳蚪＼憨坫镱翦铘蜴悴覆箔疳蝮弪乎铙趄蹉趱蝈漭垓驺哺膊疳蝮弪恒蜢孑疳蝮弪候弭躜ㄣ镱篝蜷铉倔礅镬篝蜷铉滹黝汜箦骈屐洵钺礤┅泔铘孱趔┅┅ㄤ彐轭瀛疳蝮弪蜴悴覆箔疳蝮弪烘殄熹钺礤疳蝮弪后趄轭绾狒戾狍蜴悴覆箔疳蝮弪烘翦舂ㄤ彐轭瀛疳蝮弪蜴悴覆箔疳蝮弪烘翦疳蝮弪恒栳颦轭箦ㄣ栳颦箦舡溟骀弪孱沐汨狎箦艉骢祆汨狎箦艉轶锃泔铘蝻ㄣ栳颦箦＼铛＼箴徙＼憨┅荏踱箦泗轱铥镶箫戾翦橡糸镱犰崎屐潴ù诞俯技镶箫戾翦揪ㄤ彐轭瀛疳蝮弪镡蟓镳糸镱犰í疳蝮弪垲犴蜴悴覆箔疳蝮弪烘殄熹钺礤郇疳蝮弪后趄轭绾蝈疱狒邃蜴悴覆箔疳蝮弪瑚箴┹郇疳蝮弪恒栳蚪＼憨埚犰蜴悴覆箔疳蝮弪乎铙趄蹉趱蝈漭疳蝮弪候弭躜ㄣ镱钺礤鲠飑┅茔栳痿弪涕沐铙轭琮澡轶扉怛狎轶溟篝蜷怩翦躅溴犷捎涕沐铙瀹技涕沐铙寰窘换换换换换换换换换换换换换换换换换换换换换换换换换换换换换换换换换换换换换移哺膊嗅蝮轭骘鱼桢礤换皱蝮轱换换蔑瘗蜷玷ㄣ舶肮玲蝻桩润坚蜚骈溴荔徙蜷溴锂躞换换绣蝽轶箝镱麸躞瀣泔瘗盹溟纟犷溟篝蜷怩翦翳轶箫骠麽蝈骘换犷瘐蝠矬鏖翳矧鏖翳秕驽轶桢蝈怡珧犷翦洮痱秭殇邃翳狒翳换徕秭泔瘗蜷玷铒糸沐犷翳轶疱蝽轶箝镱铒糸沐狃疱狎轭犰换泔痖弩换换匀酉圃琢遗捎幸现赡拍⒘捎廖匀琳匀弦纳用塘赏撂换琢乙廖陨庞咨匀遗橇夷韵匀捎酉圃琢遗晌锰漳晌撂赏刑膳换琢乙廖陨庞掀团颐攘卧谅商稍廖粕晕庞赢晌蜗胖盼尤撂匀换琳匀弦屡躺谅膛葡廖有琶闪态纳遗迷晌纳遗迷弦孟斡叛张卧闪换牧土桥弦廖牧土桥兹猎酉胖乓遗诱淘晌埔贤滔佑掀沼努牧粤换弦幸掀稍蝇兹旁扰晌廖撩陨衔掀孟卧伊迷闻翘汕盼门弦显扰换韵以上沼撩陨衔烈捎晌险掀弦晌孟挝琶陨衔咨匀匀沼弦换信移弦土蚊掀匀捎酉圃琢遗茔栳痿弪田徜轭犷骈戾溴疱钿孱汩弩骑翳矬麒鏖箬麸黩狃翳轶泔溴轭翳彘秣盹漉戾簌篝屙蟋翳骘祆秣轭汨躅轶痱秭殇邃技蜴悴覆箔痨衢町筱砭窘技尼翎豉疱缶技蒸殪轸殄缶技燥脲铋狒轱罹技崎屐嗅蝮轭缇技湾篌徵嗅蝮轭缇技镶箫戾翦揪